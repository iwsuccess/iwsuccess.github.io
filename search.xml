<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题</title>
      <link href="/2022/04/10/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/10/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><p><img src="/images/zijie1.jpg"><br><img src="/images/zijie2.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> int main() &#123;</span><br><span class="line"> int dx[4] = &#123; 0,0,1,-1 &#125;;</span><br><span class="line"> int dy[4] = &#123; 1,-1,0,0 &#125;;</span><br><span class="line"> int num;</span><br><span class="line"> cin &gt;&gt; num;</span><br><span class="line"> int w, h;</span><br><span class="line"> vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;res;</span><br><span class="line"> while (num&gt;0) &#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;w;</span><br><span class="line">cin&gt;&gt; h;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt;matrix(w,vector&lt;int&gt;(h));</span><br><span class="line">for (int i = 0; i &lt; w; i++)</span><br><span class="line">for (int j = 0; j &lt; h; j++)</span><br><span class="line">cin &gt;&gt; matrix[i][j];</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; w; i++) &#123;</span><br><span class="line">for (int j = 0; j &lt; h; j++) &#123;</span><br><span class="line">if (matrix[i][j] == 1) &#123;</span><br><span class="line">int water = 0;</span><br><span class="line">int new_x;</span><br><span class="line">int new_y;</span><br><span class="line">for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">new_x = i + dx[k];</span><br><span class="line">new_y = j + dy[k];</span><br><span class="line">if (new_x &gt;= 0 &amp;&amp; new_x &lt; w &amp;&amp; new_y &gt;= 0 &amp;&amp; new_y &lt; h) &#123;</span><br><span class="line">if (matrix[new_x][new_y] == 0)</span><br><span class="line">water++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (water &gt;= 2)</span><br><span class="line">matrix[i][j] = -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; w; i++)</span><br><span class="line">for (int j = 0; j &lt; h; j++)</span><br><span class="line">if (matrix[i][j] == -1)</span><br><span class="line">matrix[i][j] = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res.push_back(matrix);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num--;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //这样输出会越界，因为3维数组中的每一个二维数组可能不相同！！！  （2，3，4）</span><br><span class="line">/* for (int i = 0; i &lt; res.size(); i++) &#123;</span><br><span class="line"> for (int j = 0; j &lt; res[0].size(); j++) &#123;</span><br><span class="line"> for (int k = 0; k &lt; res[0][0].size(); k++) &#123;</span><br><span class="line"> cout &lt;&lt; res[i][j][k] &lt;&lt; &quot; &quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;*/</span><br><span class="line"> //二维数组作为缓冲，进行输出！</span><br><span class="line">  for (int i = 0; i &lt; res.size(); i++) &#123;</span><br><span class="line">  vector&lt;vector&lt;int&gt;&gt;temp=res[i];</span><br><span class="line"> for (int j = 0; j &lt; temp.size(); j++) &#123;</span><br><span class="line"> for (int k = 0; k &lt; temp[0].size(); k++) &#123;</span><br><span class="line"> cout &lt;&lt; temp[j][k] &lt;&lt; &quot; &quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2022/04/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/04/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划的常见问题"><a href="#动态规划的常见问题" class="headerlink" title="动态规划的常见问题"></a>动态规划的常见问题</h2><ul><li>动规基础（爬楼梯，斐波那契数）</li><li>背包问题</li><li>打家劫舍</li><li>股票问题</li><li>子序列问题</li></ul><h2 id="动态规划五部曲"><a href="#动态规划五部曲" class="headerlink" title="动态规划五部曲"></a>动态规划五部曲</h2><ul><li>dp数组以及下标的含义（例如dp[i],dp[i][j]等等）</li><li>递推公式</li><li>dp数组如何初始化</li><li>遍历顺序</li><li>打印dp数组</li></ul><h3 id="动态规划基础题目一：斐波那契数列"><a href="#动态规划基础题目一：斐波那契数列" class="headerlink" title="动态规划基础题目一：斐波那契数列"></a>动态规划基础题目一：斐波那契数列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1. dp[i]：第i个斐波那契数的值是dp[i].</span><br><span class="line">2. 递推公式：dp[i]=dp[i-1]+dp[i-2];</span><br><span class="line">3. 初始化：dp[0]=1,dp[1]=1.</span><br><span class="line">4. 遍历顺序：从小到大遍历.</span><br><span class="line">5. 打印dp数组，主要用来debug.</span><br><span class="line"></span><br><span class="line">解法一：</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        vector&lt;int&gt;dp(n+1,0);</span><br><span class="line">        if(n==0||n==1)</span><br><span class="line">            return n;</span><br><span class="line">        dp[0]=0;</span><br><span class="line">        dp[1]=1;</span><br><span class="line">            dp[i]=dp[i-1]+dp[i-2];</span><br><span class="line">        return dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">解法二（优化内存后，状态压缩后的解法）：</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if(n==0||n==1)</span><br><span class="line">            return n;</span><br><span class="line">    vector&lt;int&gt;dp(2,0);</span><br><span class="line">    dp[0]=0;</span><br><span class="line">    dp[1]=1;</span><br><span class="line">    int sum=0;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum=dp[0]+dp[1];</span><br><span class="line">                dp[0]=dp[1];</span><br><span class="line">                dp[1]=sum;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        return sum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态规划基础题目二：使用最小的花费爬楼梯"><a href="#动态规划基础题目二：使用最小的花费爬楼梯" class="headerlink" title="动态规划基础题目二：使用最小的花费爬楼梯"></a>动态规划基础题目二：使用最小的花费爬楼梯</h3><p><img src="/images/leetcode746.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">五部曲</span><br><span class="line">1. dp[i]：代表爬到第i阶台阶所花费的最小代价cost。</span><br><span class="line">2. 递推公式：dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])</span><br><span class="line">3. 初始化:dp[0]=0,dp[1]=0,因为可以直接从第0或者第1个台阶开始爬</span><br><span class="line">4. 遍历顺序：从小到大遍历</span><br><span class="line">5. 打印dp数组，debug手段。</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;</span><br><span class="line">        if(cost.size()==1)</span><br><span class="line">            return 0;</span><br><span class="line">        if(cost.size()==2)</span><br><span class="line">            return min(cost[0],cost[1]);</span><br><span class="line">    </span><br><span class="line">        vector&lt;int&gt;dp(cost.size()+1,0);</span><br><span class="line">        dp[0]=0;</span><br><span class="line">        dp[1]=0;</span><br><span class="line"></span><br><span class="line">        for(int i=2;i&lt;=cost.size();i++) </span><br><span class="line">            dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);</span><br><span class="line">        return dp[cost.size()];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程和线程同步</title>
      <link href="/2022/04/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/04/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="线程加锁与解锁"><a href="#线程加锁与解锁" class="headerlink" title="线程加锁与解锁"></a>线程加锁与解锁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 尝试加锁,与Lock的区别是，trylock当拿不到锁时，不会死等（不会阻塞），转而去干其他的事；而lock会一直阻塞，直至拿到锁。</span><br><span class="line">int pthread_mutex_trylock(pthread_mutex_t *mutex);</span><br><span class="line">// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中</span><br><span class="line">int pthread_mutex_lock(pthread_mutex_t *mutex);</span><br><span class="line">// 对互斥锁解锁</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ol><li>加锁之后忘记解锁<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 场景1</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0; i&lt;6; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        // 当前线程A加锁成功, 当前循环完毕没有解锁, 在下一轮循环的时候自己被阻塞了</span><br><span class="line">        // 其余的线程也被阻塞</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        // 忘记解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 场景2</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0; i&lt;6; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        // 当前线程A加锁成功</span><br><span class="line">        // 其余的线程被阻塞</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        if(xxx)</span><br><span class="line">        &#123;</span><br><span class="line">            // 函数退出, 没有解锁（解锁函数无法被执行了）</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.重复加锁，造成死锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0; i&lt;6; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        // 当前线程A加锁成功</span><br><span class="line">        // 其余的线程阻塞</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        // 锁被锁住了, A线程阻塞</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 隐藏的比较深的情况</span><br><span class="line">void funcA()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0; i&lt;6; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        // 当前线程A加锁成功</span><br><span class="line">        // 其余的线程阻塞</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void funcB()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0; i&lt;6; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        // 当前线程A加锁成功</span><br><span class="line">        // 其余的线程阻塞</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        funcA();// 重复加锁</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.当含有多个共享资源时，随意加锁，导致相互被阻塞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">thread A&#123;</span><br><span class="line">lock(x);</span><br><span class="line">lock(y);</span><br><span class="line">unlock(y);</span><br><span class="line">unlock(x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread B&#123;</span><br><span class="line">lock(y);</span><br><span class="line">lock(x);</span><br><span class="line">unlock(x);</span><br><span class="line">unlock(y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">A拿到x锁，B拿到y锁就会导致死锁。一般可以加锁顺序相同，避免死锁，但是有的特定场景不适用（对共享资源的访问顺序有要求的情况）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><ul><li><p>避免多次锁定，多检查</p></li><li><p>对共享资源访问完毕之后，一定要解锁，或者在加锁的使用 trylock</p></li><li><p>如果程序中有多把锁，可以控制对锁的访问顺序 (顺序访问共享资源，但在有些情况下是做不到的)，另外也可以在对其他互斥锁做加锁操作之前，先释放当前线程拥有的互斥锁。</p></li><li><p>项目程序中可以引入一些专门用于死锁检测的模块</p></li></ul><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ol><li>是一个锁；</li><li>读锁是共享的，写锁是互斥的；</li><li>写锁的优先级大于读的优先级。</li><li>如果说程序中所有的线程都对共享资源做写操作，使用读写锁没有优势，和互斥锁是一样的，如果说程序中所有的线程都对共享资源有写也有读操作，并且对共享资源读的操作越多，读写锁更有优势。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2022/04/04/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/04/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯算法可以解决的问题"><a href="#回溯算法可以解决的问题" class="headerlink" title="回溯算法可以解决的问题"></a>回溯算法可以解决的问题</h2><ul><li>组合问题（无序的）</li><li>切割问题（字符串的切割方式）</li><li>子集问题</li><li>排列问题（有序的）</li><li>棋盘问题（N皇后，解数独）</li></ul><h2 id="回溯法的理解"><a href="#回溯法的理解" class="headerlink" title="回溯法的理解"></a>回溯法的理解</h2><ul><li>回溯法都可抽象为一个n叉树，横向是通过for循环来处理，纵向是通过递归来处理。</li></ul><h2 id="回溯法的模板"><a href="#回溯法的模板" class="headerlink" title="回溯法的模板"></a>回溯法的模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void backtracing(参数)&#123;</span><br><span class="line">if(终止条件)&#123;</span><br><span class="line">收集结果！</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(集合的元素集)&#123;</span><br><span class="line">处理节点；</span><br><span class="line">递归函数；</span><br><span class="line">回溯操作；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void backtracing(int n,int k,vector&lt;vector&lt;int&gt;&gt;&amp;res,vector&lt;int&gt;&amp;temp,int start)&#123;</span><br><span class="line">        if(temp.size()==k)//纵向递归到叶子节点，收集结果，返回上一层递归</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">             return;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        for(int i=start;i&lt;=n;i++)&#123;//横向for循环遍历</span><br><span class="line">            if(start&gt;n-(k-temp.size())+1)//剪枝操作！！！（限制i的范围！！！）</span><br><span class="line">                return;</span><br><span class="line">            temp.push_back(i);</span><br><span class="line">            backtracing(n, k, res, temp, i+1);</span><br><span class="line">            temp.pop_back();//删除temp最后一个元素，回溯到上一层！</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;res;</span><br><span class="line">        vector&lt;int&gt;temp;</span><br><span class="line">        backtracing(n, k,res,temp,1);</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++面试准备</title>
      <link href="/2022/03/27/%E9%9D%A2%E7%BB%8F/"/>
      <url>/2022/03/27/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="编译内存相关知识"><a href="#编译内存相关知识" class="headerlink" title="编译内存相关知识"></a>编译内存相关知识</h1><h2 id="C-的编译过程"><a href="#C-的编译过程" class="headerlink" title="C++的编译过程"></a>C++的编译过程</h2><h3 id="共分为四个步骤：编译预处理，编译，汇编，链接。"><a href="#共分为四个步骤：编译预处理，编译，汇编，链接。" class="headerlink" title="共分为四个步骤：编译预处理，编译，汇编，链接。"></a>共分为四个步骤：编译预处理，编译，汇编，链接。</h3><ul><li>编译预处理：处理#字符开头的指令。</li><li>编译：将源码.cpp文件编译成.s文件。</li><li>汇编：将.s文件汇编成.o文件。</li><li>链接：将一个或者多个.o文件链接形成.exe的可执行文件。<h3 id="静态链接和动态链接的区别"><a href="#静态链接和动态链接的区别" class="headerlink" title="静态链接和动态链接的区别"></a>静态链接和动态链接的区别</h3></li><li>静态链接：代码从其所在的静态链接库中的拷贝到可执行程序中，优点是执行速度快；缺点是浪费空间，因为可能会拷贝多份重复的代码，并且在目标文件更新后，需要重新编译链接生成新的exe文件。</li><li>动态链接：动态链接时并没有将真正的代码链接进去，而是保存了一个映射，在执行过程中，通过该映射再去寻找真正的代码。优点是节省内存，更新方便。缺点是相比静态链接速度较慢，性能有一定的损失。</li></ul><h2 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h2><h3 id="C-的内存分为栈，堆，全局区-x2F-静态区，代码区，常量区。"><a href="#C-的内存分为栈，堆，全局区-x2F-静态区，代码区，常量区。" class="headerlink" title="C++的内存分为栈，堆，全局区&#x2F;静态区，代码区，常量区。"></a>C++的内存分为栈，堆，全局区&#x2F;静态区，代码区，常量区。</h3><ul><li>栈：通常是局部变量，函数参数，返回值存放的地方，由编译器自动回收。</li><li>堆：程序员自己malloc申请的内存块，需要程序员自己申请和释放。</li><li>全局区&#x2F;静态区：静态变量和全局变量存储的地方，程序结束会自动释放。</li><li>常量区：存放常量，不允许修改，程序结束后会自动释放。</li><li>代码区：存放代码，不允许修改，可以执行。编译后的二进制文件存放的地方。</li><li>示例代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a = 0; // </span><br><span class="line">char *b;  // a,b均在全局区</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int v;//v在栈区</span><br><span class="line">   int *p=(int*)malloc(sizeof(int)*4)//申请16个字节内存在堆区</span><br><span class="line">   static int e;//e在静态区</span><br><span class="line">   string s=&quot;abvdefr&quot;;//s在栈区，&quot;abvdefr&quot;在常量区 </span><br><span class="line">   int d[]=&quot;qwe&quot;;//d在栈区，&quot;qwe&quot;在常量区</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h3><ol><li>申请和回收方式不同：栈由系统分配和回收，堆由程序员申请和回收。</li><li>存储方式不同：栈是一块连续的内存空间（向低地址扩展），堆的内存空间是不连续的（链表结构），(向高地址扩展)。</li><li>存放的内容不同：栈存放局部变量，函数参数，返回值等，堆存放的内容由程序员控制。</li><li>效率：栈的申请由系统自动分配，效率高。堆效率低，也容易产生内存碎片。</li><li>申请后的系统响应方式不同：栈空间申请后，如果当前剩余空间&gt;申请空间，则分配，否则，提示栈溢出；堆空间申请后，需要在链表上的寻找第一块大于等于申请空间的内存块，找到后将该块（首地址存放了本次分配的空间大小）从内存链表上删除，分配给堆空间，将剩余的空间链接在空闲链表上，用完回收后，再将其链接在空闲链表上。</li></ol><h2 id="全局变量，静态全局变量，局部变量，静态局部变量的区别"><a href="#全局变量，静态全局变量，局部变量，静态局部变量的区别" class="headerlink" title="全局变量，静态全局变量，局部变量，静态局部变量的区别"></a>全局变量，静态全局变量，局部变量，静态局部变量的区别</h2><ul><li>全局变量：具有全局作用域，全局变量只要在一个源文件中定义，就可以在同一工程中的其他源文件中使用，只不过需要利用关键字extern声明这个全局变量。</li><li>静态全局变量（static修饰的）：具有文件作用域，其他文件不能使用该全局变量，即使另一个文件中定义了与之同名的静态全局变量，也是不同的变量。</li><li>局部变量：具有局部作用域，并不是一直存在，只是在其作用域内存在，出了其作用域就会被回收。</li><li>局部静态变量：具有局部作用域，只初始化一次，到程序运行结束前一直存在，只对定义自己的函数体可见（自己作用域内），出了作用域就不可见。</li></ul><h2 id="pragma-once和-ifndef-define-endif解读"><a href="#pragma-once和-ifndef-define-endif解读" class="headerlink" title="#pragma once和#ifndef #define #endif解读"></a>#pragma once和#ifndef #define #endif解读</h2><h3 id="作用：都是为了防止同一个头文件被重复编译。即：在同一个cpp文件中重复包含了某一个头文件（嵌套头文件时容易出现，例如-a-h中包含了b-h-但是在c-cpp中包含了a-h和b-h，即：b-h就被重复包含了）。"><a href="#作用：都是为了防止同一个头文件被重复编译。即：在同一个cpp文件中重复包含了某一个头文件（嵌套头文件时容易出现，例如-a-h中包含了b-h-但是在c-cpp中包含了a-h和b-h，即：b-h就被重复包含了）。" class="headerlink" title="作用：都是为了防止同一个头文件被重复编译。即：在同一个cpp文件中重复包含了某一个头文件（嵌套头文件时容易出现，例如:a.h中包含了b.h,但是在c.cpp中包含了a.h和b.h，即：b.h就被重复包含了）。"></a>作用：都是为了防止同一个头文件被重复编译。即：在同一个cpp文件中重复包含了某一个头文件（嵌套头文件时容易出现，例如:a.h中包含了b.h,但是在c.cpp中包含了a.h和b.h，即：b.h就被重复包含了）。</h3><h3 id="头文件中不能声明全局变量，因为当头文件中声明了全局变量后，如果多个-cpp文件中包含了这个头文件，这个全局变量就会被定义多次，出现重复定义错误。"><a href="#头文件中不能声明全局变量，因为当头文件中声明了全局变量后，如果多个-cpp文件中包含了这个头文件，这个全局变量就会被定义多次，出现重复定义错误。" class="headerlink" title="头文件中不能声明全局变量，因为当头文件中声明了全局变量后，如果多个.cpp文件中包含了这个头文件，这个全局变量就会被定义多次，出现重复定义错误。"></a>头文件中不能声明全局变量，因为当头文件中声明了全局变量后，如果多个.cpp文件中包含了这个头文件，这个全局变量就会被定义多次，出现重复定义错误。</h3><h2 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h2><p>1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</p><p>2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</p><p>3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</p><h2 id="public-protected-private访问权限"><a href="#public-protected-private访问权限" class="headerlink" title="public,protected,private访问权限"></a>public,protected,private访问权限</h2><p><img src="/images/lei.png"></p><h2 id="如何限制类的对象只能在堆上创建，如何限制对象只能在栈创建"><a href="#如何限制类的对象只能在堆上创建，如何限制对象只能在栈创建" class="headerlink" title="如何限制类的对象只能在堆上创建，如何限制对象只能在栈创建"></a>如何限制类的对象只能在堆上创建，如何限制对象只能在栈创建</h2><h3 id="创建对象的方式有两种，即：堆创建（new出来的）和栈创建-一般创建，例如：A-a-。"><a href="#创建对象的方式有两种，即：堆创建（new出来的）和栈创建-一般创建，例如：A-a-。" class="headerlink" title="创建对象的方式有两种，即：堆创建（new出来的）和栈创建(一般创建，例如：A a)。"></a>创建对象的方式有两种，即：堆创建（new出来的）和栈创建(一般创建，例如：A a)。</h3><ol><li>限制对象只能创建在栈上：通过重载new和detele函数为类的私有函数，因为默认的new创建会将对象创建在堆上。</li><li>限制对象只能创建在堆上：将构造和析构置为保护，在类外调用create构造对象（堆上创建），析构置为保护是为了在其派生类中也能访问析构函数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static A *create()</span><br><span class="line">    &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">    void destory()</span><br><span class="line">    &#123;</span><br><span class="line">        delete this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题</title>
      <link href="/2022/03/26/leetcode/"/>
      <url>/2022/03/26/leetcode/</url>
      
        <content type="html"><![CDATA[<h2 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h2><p><img src="/images/leetcode189.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">       k=k%nums.size();     </span><br><span class="line">       vector&lt;int&gt;temp;</span><br><span class="line">       for(int i=0;i&lt;nums.size();i++)  //创建一个临时数组，保存对应保存nums的所有元素</span><br><span class="line">            temp.push_back(nums[i]);   </span><br><span class="line">      int i=0;//记录当前需要移动的元素下标</span><br><span class="line">      while(i&lt;nums.size())&#123;  </span><br><span class="line">          int new_index=(i+k)%nums.size(); //当前元素移动后的最终位置！</span><br><span class="line">          nums[new_index]=temp[i];//将当前元素（待移动元素）放在轮转后的最终位置上。</span><br><span class="line">          i++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test日志</title>
      <link href="/2022/03/26/first-blog/"/>
      <url>/2022/03/26/first-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="我的第一个测试日志"><a href="#我的第一个测试日志" class="headerlink" title="我的第一个测试日志"></a>我的第一个测试日志</h2><h3 id="时间-2022-3-26-星期六"><a href="#时间-2022-3-26-星期六" class="headerlink" title="时间: 2022-3-26 星期六"></a>时间: 2022-3-26 星期六</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
