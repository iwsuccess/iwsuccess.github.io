<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++面试准备</title>
      <link href="/2022/03/27/%E9%9D%A2%E7%BB%8F/"/>
      <url>/2022/03/27/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="编译内存相关知识"><a href="#编译内存相关知识" class="headerlink" title="编译内存相关知识"></a>编译内存相关知识</h1><h2 id="C-的编译过程"><a href="#C-的编译过程" class="headerlink" title="C++的编译过程"></a>C++的编译过程</h2><h3 id="共分为四个步骤：编译预处理，编译，汇编，链接。"><a href="#共分为四个步骤：编译预处理，编译，汇编，链接。" class="headerlink" title="共分为四个步骤：编译预处理，编译，汇编，链接。"></a>共分为四个步骤：编译预处理，编译，汇编，链接。</h3><ul><li>编译预处理：处理#字符开头的指令。</li><li>编译：将源码.cpp文件编译成.s文件。</li><li>汇编：将.s文件汇编成.o文件。</li><li>链接：将一个或者多个.o文件链接形成.exe的可执行文件。<h3 id="静态链接和动态链接的区别"><a href="#静态链接和动态链接的区别" class="headerlink" title="静态链接和动态链接的区别"></a>静态链接和动态链接的区别</h3></li><li>静态链接：代码从其所在的静态链接库中的拷贝到可执行程序中，优点是执行速度快；缺点是浪费空间，因为可能会拷贝多份重复的代码，并且在目标文件更新后，需要重新编译链接生成新的exe文件。</li><li>动态链接：动态链接时并没有将真正的代码链接进去，而是保存了一个映射，在执行过程中，通过该映射再去寻找真正的代码。优点是节省内存，更新方便。缺点是相比静态链接速度较慢，性能有一定的损失。</li></ul><h2 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h2><h3 id="C-的内存分为栈，堆，全局区-x2F-静态区，代码区，常量区。"><a href="#C-的内存分为栈，堆，全局区-x2F-静态区，代码区，常量区。" class="headerlink" title="C++的内存分为栈，堆，全局区&#x2F;静态区，代码区，常量区。"></a>C++的内存分为栈，堆，全局区&#x2F;静态区，代码区，常量区。</h3><ul><li>栈：通常是局部变量，函数参数，返回值存放的地方，由编译器自动回收。</li><li>堆：程序员自己malloc申请的内存块，需要程序员自己申请和释放。</li><li>全局区&#x2F;静态区：静态变量和全局变量存储的地方，程序结束会自动释放。</li><li>常量区：存放常量，不允许修改，程序结束后会自动释放。</li><li>代码区：存放代码，不允许修改，可以执行。编译后的二进制文件存放的地方。</li><li>示例代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a = 0; // </span><br><span class="line">char *b;  // a,b均在全局区</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int v;//v在栈区</span><br><span class="line">   int *p=(int*)malloc(sizeof(int)*4)//申请16个字节内存在堆区</span><br><span class="line">   static int e;//e在静态区</span><br><span class="line">   string s=&quot;abvdefr&quot;;//s在栈区，&quot;abvdefr&quot;在常量区 </span><br><span class="line">   int d[]=&quot;qwe&quot;;//d在栈区，&quot;qwe&quot;在常量区</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h3><ol><li>申请和回收方式不同：栈由系统分配和回收，堆由程序员申请和回收。</li><li>存储方式不同：栈是一块连续的内存空间（向低地址扩展），堆的内存空间是不连续的（链表结构），(向高地址扩展)。</li><li>存放的内容不同：栈存放局部变量，函数参数，返回值等，堆存放的内容由程序员控制。</li><li>效率：栈的申请由系统自动分配，效率高。堆效率低，也容易产生内存碎片。</li><li>申请后的系统响应方式不同：栈空间申请后，如果当前剩余空间&gt;申请空间，则分配，否则，提示栈溢出；堆空间申请后，需要在链表上的寻找第一块大于等于申请空间的内存块，找到后将该块（首地址存放了本次分配的空间大小）从内存链表上删除，分配给堆空间，将剩余的空间链接在空闲链表上，用完回收后，再将其链接在空闲链表上。</li></ol><h2 id="全局变量，静态全局变量，局部变量，静态局部变量的区别"><a href="#全局变量，静态全局变量，局部变量，静态局部变量的区别" class="headerlink" title="全局变量，静态全局变量，局部变量，静态局部变量的区别"></a>全局变量，静态全局变量，局部变量，静态局部变量的区别</h2><ul><li>全局变量：具有全局作用域，全局变量只要在一个源文件中定义，就可以在同一工程中的其他源文件中使用，只不过需要利用关键字extern声明这个全局变量。</li><li>静态全局变量（static修饰的）：具有文件作用域，其他文件不能使用该全局变量，即使另一个文件中定义了与之同名的静态全局变量，也是不同的变量。</li><li>局部变量：具有局部作用域，并不是一直存在，只是在其作用域内存在，出了其作用域就会被回收。</li><li>局部静态变量：具有局部作用域，只初始化一次，到程序运行结束前一直存在，只对定义自己的函数体可见（自己作用域内），出了作用域就不可见。</li></ul><h2 id="pragma-once和-ifndef-define-endif解读"><a href="#pragma-once和-ifndef-define-endif解读" class="headerlink" title="#pragma once和#ifndef #define #endif解读"></a>#pragma once和#ifndef #define #endif解读</h2><h3 id="作用：都是为了防止同一个头文件被重复编译。即：在同一个cpp文件中重复包含了某一个头文件（嵌套头文件时容易出现，例如-a-h中包含了b-h-但是在c-cpp中包含了a-h和b-h，即：b-h就被重复包含了）。"><a href="#作用：都是为了防止同一个头文件被重复编译。即：在同一个cpp文件中重复包含了某一个头文件（嵌套头文件时容易出现，例如-a-h中包含了b-h-但是在c-cpp中包含了a-h和b-h，即：b-h就被重复包含了）。" class="headerlink" title="作用：都是为了防止同一个头文件被重复编译。即：在同一个cpp文件中重复包含了某一个头文件（嵌套头文件时容易出现，例如:a.h中包含了b.h,但是在c.cpp中包含了a.h和b.h，即：b.h就被重复包含了）。"></a>作用：都是为了防止同一个头文件被重复编译。即：在同一个cpp文件中重复包含了某一个头文件（嵌套头文件时容易出现，例如:a.h中包含了b.h,但是在c.cpp中包含了a.h和b.h，即：b.h就被重复包含了）。</h3><h3 id="头文件中不能声明全局变量，因为当头文件中声明了全局变量后，如果多个-cpp文件中包含了这个头文件，这个全局变量就会被定义多次，出现重复定义错误。"><a href="#头文件中不能声明全局变量，因为当头文件中声明了全局变量后，如果多个-cpp文件中包含了这个头文件，这个全局变量就会被定义多次，出现重复定义错误。" class="headerlink" title="头文件中不能声明全局变量，因为当头文件中声明了全局变量后，如果多个.cpp文件中包含了这个头文件，这个全局变量就会被定义多次，出现重复定义错误。"></a>头文件中不能声明全局变量，因为当头文件中声明了全局变量后，如果多个.cpp文件中包含了这个头文件，这个全局变量就会被定义多次，出现重复定义错误。</h3><h2 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h2><p>1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</p><p>2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</p><p>3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</p><h2 id="public-protected-private访问权限"><a href="#public-protected-private访问权限" class="headerlink" title="public,protected,private访问权限"></a>public,protected,private访问权限</h2><p><img src="/images/lei.png"></p><h2 id="如何限制类的对象只能在堆上创建，如何限制对象只能在栈创建"><a href="#如何限制类的对象只能在堆上创建，如何限制对象只能在栈创建" class="headerlink" title="如何限制类的对象只能在堆上创建，如何限制对象只能在栈创建"></a>如何限制类的对象只能在堆上创建，如何限制对象只能在栈创建</h2><h3 id="创建对象的方式有两种，即：堆创建（new出来的）和栈创建-一般创建，例如：A-a-。"><a href="#创建对象的方式有两种，即：堆创建（new出来的）和栈创建-一般创建，例如：A-a-。" class="headerlink" title="创建对象的方式有两种，即：堆创建（new出来的）和栈创建(一般创建，例如：A a)。"></a>创建对象的方式有两种，即：堆创建（new出来的）和栈创建(一般创建，例如：A a)。</h3><ol><li>限制对象只能创建在栈上：通过重载new和detele函数为类的私有函数，因为默认的new创建会将对象创建在堆上。</li><li>限制对象只能创建在堆上：将构造和析构置为保护，在类外调用create构造对象（堆上创建），析构置为保护是为了在其派生类中也能访问析构函数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static A *create()</span><br><span class="line">    &#123;</span><br><span class="line">        return new A();</span><br><span class="line">    &#125;</span><br><span class="line">    void destory()</span><br><span class="line">    &#123;</span><br><span class="line">        delete this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题</title>
      <link href="/2022/03/26/leetcode/"/>
      <url>/2022/03/26/leetcode/</url>
      
        <content type="html"><![CDATA[<h2 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h2><p><img src="/images/leetcode189.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">       k=k%nums.size();     </span><br><span class="line">       vector&lt;int&gt;temp;</span><br><span class="line">       for(int i=0;i&lt;nums.size();i++)  //创建一个临时数组，保存对应保存nums的所有元素</span><br><span class="line">            temp.push_back(nums[i]);   </span><br><span class="line">      int i=0;//记录当前需要移动的元素下标</span><br><span class="line">      while(i&lt;nums.size())&#123;  </span><br><span class="line">          int new_index=(i+k)%nums.size(); //当前元素移动后的最终位置！</span><br><span class="line">          nums[new_index]=temp[i];//将当前元素（待移动元素）放在轮转后的最终位置上。</span><br><span class="line">          i++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test日志</title>
      <link href="/2022/03/26/first-blog/"/>
      <url>/2022/03/26/first-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="我的第一个测试日志"><a href="#我的第一个测试日志" class="headerlink" title="我的第一个测试日志"></a>我的第一个测试日志</h2><h3 id="时间-2022-3-26-星期六"><a href="#时间-2022-3-26-星期六" class="headerlink" title="时间: 2022-3-26 星期六"></a>时间: 2022-3-26 星期六</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
