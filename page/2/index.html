<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="努力变强">
<meta property="og:type" content="website">
<meta property="og:title" content="一懒众衫小">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="一懒众衫小">
<meta property="og:description" content="努力变强">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="qcc">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>一懒众衫小</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
     <a target="_blank" rel="noopener" href="https://iwsuccess.github.io" class="github-corner" aria-label="View source on GitHub">
	<svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
		<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
		<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
		<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
	</svg>
     </a>
	<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}
	</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">一懒众衫小</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Freedom On High</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/03/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">守护进程和线程</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-03 21:04:58" itemprop="dateCreated datePublished" datetime="2022-05-03T21:04:58+08:00">2022-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-09 21:49:04" itemprop="dateModified" datetime="2022-05-09T21:49:04+08:00">2022-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="守护进程的特点"><a href="#守护进程的特点" class="headerlink" title="守护进程的特点:"></a>守护进程的特点:</h2><pre><code>1 一个linux后台服务进程
2 不依赖于控制终端
3 周期性执行某些任务
4 不受用户登录和注销的影响
5 一般以d结尾
</code></pre>
<h2 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话:"></a>进程组和会话:</h2><pre><code>进程组: 一个进程包含多个进程
会话: 多个组组成一个会话.

创建会话的进程不能是组长进程;
一般创建会话是父进程先fork子进程, 然后父进程退出, 让子进程调用setsid函数
创建一个会话, 这个子进程既是会长也是组长;
只要是创建了会话, 这个进程就脱离了控制终端的影响.
</code></pre>
<h2 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型:"></a>创建守护进程模型:</h2><pre><code>1 父进程fork子进程, 然后父进程退出.
   目的是: 子进程肯定不是组长进程, 为后续调用setsid函数提供了条件.
2 子进程调用setsid函数创建一个新的会话.
    1 该子进程成了该会话的会长
    2 该子进程成了该组的组长进程.
    3 不再受控制终端的影响了
3 改变当前的工作目录, chdir  -----不是必须的
4 重设文件掩码, umask(0000)  -----不是必须的
5 关闭STDIN_FILENO  STDOUT_FILENO STDERR_FILENO   ---不是必须的
6 核心操作
</code></pre>
<h2 id="编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。"><a href="#编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。" class="headerlink" title="编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。"></a>编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。</h2><p>分析：首先要按照1.3介绍的守护进行的步骤创建一个守护进程.<br>    每隔2S钟: 使用setitimer函数设置时钟, 该时钟发送的是SIGALRM信号,<br>    信号操作: 注册信号处理函数,signal或者sigaction, 还有一个信号处理函数<br>    获取一次系统时间: time函数的使用, ctime函数的使用<br>    写入磁盘文件: 文件操作函数: open write close </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//创建守护进程</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void clock_process(int signo)&#123;</span><br><span class="line">	</span><br><span class="line">	//0755文件权限指定，是配合O_CREAT使用的，如果没有该文件，则以0755权限创建文件</span><br><span class="line">	int fd=open(&quot;mydemo.log&quot;, O_RDWR|O_CREAT|O_APPEND,0755);</span><br><span class="line">	if(fd&lt;0)&#123;</span><br><span class="line">		//此时perror不能打印出错误，因为该进程已经摆脱了控制终端，无法输出到标准输出</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//获取当前的系统时间</span><br><span class="line">	time_t cur_time;</span><br><span class="line">	time(&amp;cur_time);</span><br><span class="line">	//转化为字符串</span><br><span class="line">	char *cur_time_s=ctime(&amp;cur_time);</span><br><span class="line">	//将时间写入文件</span><br><span class="line">	write(fd,cur_time_s,strlen(cur_time_s));</span><br><span class="line">	close(fd);</span><br><span class="line">	return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	pid_t pid=fork();</span><br><span class="line">	//父进程退出</span><br><span class="line">	if(pid&lt;0||pid&gt;0)&#123;</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//子进程创建会话</span><br><span class="line">	setsid();</span><br><span class="line">	</span><br><span class="line">	//改变当前的工作目录</span><br><span class="line">	chdir(&quot;/home/qcc/log&quot;);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//改变文件掩码</span><br><span class="line">	umask(0000);</span><br><span class="line">	</span><br><span class="line">	//关闭标准输入，标准输出，标准错误的文件描述符</span><br><span class="line">	close(STDOUT_FILENO);</span><br><span class="line">	close(STDIN_FILENO);</span><br><span class="line">	close(STDERR_FILENO);</span><br><span class="line">	</span><br><span class="line">	//核心操作</span><br><span class="line">	//注册信号处理函数</span><br><span class="line">	struct sigaction act;</span><br><span class="line">	act.sa_handler=clock_process;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	act.sa_flags=0;</span><br><span class="line">	sigaction(SIGALRM,&amp;act,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//设置时钟</span><br><span class="line">	struct itimerval tm;</span><br><span class="line">	//设置周期时间</span><br><span class="line">	tm.it_interval.tv_sec=2;</span><br><span class="line">	tm.it_interval.tv_usec=0;</span><br><span class="line">	//设置开始时间，3秒后</span><br><span class="line">	tm.it_value.tv_sec=3;</span><br><span class="line">	tm.it_value.tv_usec=0;</span><br><span class="line">	setitimer(ITIMER_REAL, &amp;tm, NULL);</span><br><span class="line">	</span><br><span class="line">	//该语句不会打印出来，因为子进程已经脱离了终端的控制</span><br><span class="line">	printf(&quot;hello world\n&quot;);</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优化:<br>    1 不再频繁的打开和关闭文件<br>    2 如何控制log文件大小  test.log</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">//创建守护进程</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int flag=0;//控制文件只打开一次</span><br><span class="line">int fd;</span><br><span class="line"></span><br><span class="line">void clock_process(int signo)&#123;</span><br><span class="line">	</span><br><span class="line">	//0755文件权限指定，是配合O_CREAT使用的，如果没有该文件，则以0755权限创建文件</span><br><span class="line">	</span><br><span class="line">	if(flag==0)&#123;</span><br><span class="line">		fd=open(&quot;mydemo.log&quot;, O_RDWR|O_CREAT|O_APPEND,0755);</span><br><span class="line">		if(fd&lt;0)&#123;</span><br><span class="line">			//此时perror不能打印出错误，因为该进程已经摆脱了控制终端，无法输出到标准输出</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		flag=1;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取当前的系统时间</span><br><span class="line">	time_t cur_time;</span><br><span class="line">	time(&amp;cur_time);</span><br><span class="line">	//转化为字符串</span><br><span class="line">	char *cur_time_s=ctime(&amp;cur_time);</span><br><span class="line">	//将时间写入文件</span><br><span class="line">	write(fd,cur_time_s,strlen(cur_time_s));</span><br><span class="line">	</span><br><span class="line">	return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	pid_t pid=fork();</span><br><span class="line">	//父进程退出</span><br><span class="line">	if(pid&lt;0||pid&gt;0)&#123;</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//子进程创建会话</span><br><span class="line">	setsid();</span><br><span class="line">	</span><br><span class="line">	//改变当前的工作目录</span><br><span class="line">	chdir(&quot;/home/qcc/log&quot;);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//改变文件掩码</span><br><span class="line">	umask(0000);</span><br><span class="line">	</span><br><span class="line">	//关闭标准输入，标准输出，标准错误的文件描述符</span><br><span class="line">	close(STDOUT_FILENO);</span><br><span class="line">	close(STDIN_FILENO);</span><br><span class="line">	close(STDERR_FILENO);</span><br><span class="line">	</span><br><span class="line">	//核心操作</span><br><span class="line">	//注册信号处理函数</span><br><span class="line">	struct sigaction act;</span><br><span class="line">	act.sa_handler=clock_process;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	act.sa_flags=0;</span><br><span class="line">	sigaction(SIGALRM,&amp;act,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//设置时钟</span><br><span class="line">	struct itimerval tm;</span><br><span class="line">	//设置周期时间</span><br><span class="line">	tm.it_interval.tv_sec=2;</span><br><span class="line">	tm.it_interval.tv_usec=0;</span><br><span class="line">	//设置开始时间，3秒后</span><br><span class="line">	tm.it_value.tv_sec=3;</span><br><span class="line">	tm.it_value.tv_usec=0;</span><br><span class="line">	setitimer(ITIMER_REAL, &amp;tm, NULL);</span><br><span class="line">	</span><br><span class="line">	//该语句不会打印出来，因为子进程已经脱离了终端的控制</span><br><span class="line">	printf(&quot;hello world\n&quot;);</span><br><span class="line">	</span><br><span class="line">	int j=0;</span><br><span class="line">	char des[64];</span><br><span class="line">	char temp[10];</span><br><span class="line">	char *copy_file=&quot;./mydemo.log.bak&quot;;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		//获取文件大小</span><br><span class="line">		int size=lseek(fd,0,SEEK_END);</span><br><span class="line">		if(size&gt;100)&#123;//文件如果大于100，就保存一个副本！</span><br><span class="line">			close(fd);</span><br><span class="line">			j++;</span><br><span class="line">			memset(temp,0x00,sizeof(temp));</span><br><span class="line">			sprintf(temp,&quot;%d&quot;,j);//整数转为字符串</span><br><span class="line">			memset(des,0x00,sizeof(des));</span><br><span class="line">			sprintf(des,&quot;%s.%s&quot;,copy_file,temp);</span><br><span class="line">			rename(&quot;./mydemo.log&quot;,des);</span><br><span class="line">			flag=0;//保存副本了，下次需要重新打开文件</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	close(fd);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ul>
<li><p>线程的基本概念<br><img src="/images/thread.png"></p>
</li>
<li><p>循环创建子线程<br><img src="/images/multithread.png"></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//循环创建子线程，并且打印是第几个子线程</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void *mythread(void *arg)&#123;</span><br><span class="line">	int *ret=(int *)arg;</span><br><span class="line">	printf(&quot;child thread num=[%d]\n&quot;,*ret);</span><br><span class="line">	printf(&quot;child thread,process_id=[%d],thread_id=[%ld]\n&quot;,getpid(),pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	pthread_t pid[5];</span><br><span class="line">	int n=5;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0;i&lt;n;i++)</span><br><span class="line">	&#123;	</span><br><span class="line">		int *temp=(int *)malloc(sizeof(int));</span><br><span class="line">		*temp=i;</span><br><span class="line">		int ret=pthread_create(&amp;pid[i],NULL,mythread,temp);</span><br><span class="line">		if(ret!=0)&#123;</span><br><span class="line">			printf(&quot;pthread_create failed. reason:[%s]\n&quot;,strerror(ret));</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;main thread,process_id=[%d],thread_id=[%ld]\n&quot;,getpid(),pthread_self());</span><br><span class="line">	</span><br><span class="line">	//目的是为了让子线程能执行起来，防止主线程结束后，子线程还未执行结束</span><br><span class="line">	sleep(1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ps-Lf-进程id"><a href="#ps-Lf-进程id" class="headerlink" title="ps -Lf 进程id"></a>ps -Lf 进程id</h3><p>查看进程中的所有线程</p>
<h2 id="线程相关函数"><a href="#线程相关函数" class="headerlink" title="线程相关函数:"></a>线程相关函数:</h2><pre><code>1 创建子线程: pthread_create
2 线程退出: pthread_exit
3 回收子线程: pthread_join
4 设置子线程为分离属性，设置后子线程会自己回收自己: pthread_detach
</code></pre>
<h2 id="进程和线程的函数比较"><a href="#进程和线程的函数比较" class="headerlink" title="进程和线程的函数比较"></a>进程和线程的函数比较</h2><p><img src="/images/compare.png"></p>
<h2 id="在创建线程的时候设置线程属性为分离属性-默认为非分离属性，传NULL即可"><a href="#在创建线程的时候设置线程属性为分离属性-默认为非分离属性，传NULL即可" class="headerlink" title="在创建线程的时候设置线程属性为分离属性(默认为非分离属性，传NULL即可):"></a>在创建线程的时候设置线程属性为分离属性(默认为非分离属性，传NULL即可):</h2><pre><code>1 pthread_attr_t attr;
2 pthread_attr_init(&amp;attr);
3 pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
4 pthread_create(&amp;thread, &amp;attr, mythread, NULL);
5 pthread_attr_destroy(&amp;attr);//最后记得释放属性内存
</code></pre>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li><p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p>
</li>
<li><p>两个线程数数分析：<br><img src="/images/num.png"></p>
</li>
<li><p>加锁解决</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">int num=0;</span><br><span class="line">void *mythread(void *arg)&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0;i&lt;10000;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		num++;</span><br><span class="line">		printf(&quot;pthread=[%ld]:num=[%d]\n&quot;,pthread_self(),num);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	pthread_t pid1;</span><br><span class="line">	pthread_t pid2;</span><br><span class="line">	</span><br><span class="line">	//初始化锁</span><br><span class="line">	pthread_mutex_init(&amp;mutex,NULL);</span><br><span class="line">	</span><br><span class="line">	int ret=pthread_create(&amp;pid1,NULL,mythread,NULL);</span><br><span class="line">	if(ret!=0)&#123;</span><br><span class="line">		printf(&quot;pthread_create failed. reason:[%s]\n&quot;,strerror(ret));</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	ret=pthread_create(&amp;pid2,NULL,mythread,NULL);</span><br><span class="line">	if(ret!=0)&#123;</span><br><span class="line">		printf(&quot;pthread_create failed. reason:[%s]\n&quot;,strerror(ret));</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	pthread_join(pid1,NULL);</span><br><span class="line">	pthread_join(pid2,NULL);</span><br><span class="line">	</span><br><span class="line">	//释放锁</span><br><span class="line">	pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好"><a href="#在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好" class="headerlink" title="在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好."></a>在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好.</h2><h2 id="互斥量-也叫互斥锁"><a href="#互斥量-也叫互斥锁" class="headerlink" title="互斥量(也叫互斥锁)"></a>互斥量(也叫互斥锁)</h2><pre><code>第1步：创建一把互斥锁
pthread_mutex_t mutex;
初始化互斥锁
pthread_mutex_init(&amp;mutex);---相当于mutex=1
在代码中寻找共享资源（也称为临界区）
pthread_mutex_lock(&amp;mutex);  -- mutex = 0
[临界区代码]
pthread_mutex_unlock(&amp;mutex); -- mutex = 1
释放互斥锁资源
pthread_mutex_destroy(&amp;mutex);
注意：必须在所有操作共享资源的线程上都加上锁否则不能起到同步的效果。
</code></pre>
<h2 id="死锁-死锁不是linux提供给开发者的一种机制-而是由于开发者操作不当引起的"><a href="#死锁-死锁不是linux提供给开发者的一种机制-而是由于开发者操作不当引起的" class="headerlink" title="死锁: 死锁不是linux提供给开发者的一种机制, 而是由于开发者操作不当引起的."></a>死锁: 死锁不是linux提供给开发者的一种机制, 而是由于开发者操作不当引起的.</h2><pre><code>1 自己锁自己.
    注意点: 线程在异常退出的时候也需要解锁.
2 A线程占用着A锁, 又想去获得B锁; B线程占用着B锁, 又想去获得A锁, 
  两个线程都不释放自己的锁, 又想去获得对方的锁, 从而造成了死锁.
  解决方法:
      1 需要先释放自己的锁再去获得其他锁
      2 避免使用嵌套的锁, 让线程按照一定的顺序加锁
      3 可以调用pthread_mutex_trylock函数加锁, 该函数不阻塞, 所以不会产生死锁.
</code></pre>
<h2 id="读写锁-读写锁是一把锁"><a href="#读写锁-读写锁是一把锁" class="headerlink" title="读写锁:读写锁是一把锁"></a>读写锁:读写锁是一把锁</h2><pre><code>读写锁场景练习:
线程A加写锁成功, 线程B请求读锁
    线程B阻塞, 
    当线程A解锁之后, 线程B加锁成功

线程A持有读锁, 线程B请求写锁
    线程B会阻塞;
    当线程A解锁之后, 线程B加锁成功

线程A拥有读锁, 线程B请求读锁
    线程B请求锁成功

线程A持有读锁, 然后线程B请求写锁, 然后线程C请求读锁
    线程B和C都阻塞;
    当A释放锁之后, B先获得锁, C阻塞
    当B释放锁之后, C获得锁    

线程A持有写锁, 然后线程B请求读锁, 然后线程C请求写锁
    线程B和C都阻塞;
    当线程A解锁之后, C先获得锁, B阻塞;
    当C解锁之后, B获得锁
</code></pre>
<h2 id="读写锁总结"><a href="#读写锁总结" class="headerlink" title="读写锁总结"></a>读写锁总结</h2><pre><code>写独占, 读共享, 当读和写一起等待锁的时候, 写的优先级高
</code></pre>
<h2 id="读写锁使用步骤"><a href="#读写锁使用步骤" class="headerlink" title="读写锁使用步骤:"></a>读写锁使用步骤:</h2><pre><code>1 先定义一把读写锁:
    pthread_rwlock_t rwlock;
2 初始化读写锁
    pthread_rwlock_init(&amp;rwlock, NULL);
3 加锁
    pthread_rwlock_rdlock(&amp;rwlock);----&gt;加读锁
    pthread_rwlock_wrlock(&amp;rwlock);----&gt;加写锁
    ////////////////////////
    共享资源出现的位置
    /////////////////////////
4 解锁
    pthread_rwlock_unlock(&amp;rwlock);
5 释放锁
    pthread_rwlock_destroy(&amp;rwlock);
</code></pre>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><ul>
<li>生产者消费者模型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct node&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">//创建虚拟头结点</span><br><span class="line">Node *dummy_head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pthread_cond_t cond;</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"></span><br><span class="line">//生产者线程</span><br><span class="line">void *producer(void *arg)&#123;</span><br><span class="line">	</span><br><span class="line">	int no=*(int *)arg;</span><br><span class="line">	Node *p=NULL;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">	</span><br><span class="line">		//尾插法</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		Node *pnode=(Node *)malloc(sizeof(Node));</span><br><span class="line">		p=dummy_head;</span><br><span class="line">		pnode-&gt;data=rand()%1000;</span><br><span class="line">		</span><br><span class="line">		while(p-&gt;next!=NULL)&#123;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">		p-&gt;next=pnode;</span><br><span class="line">		pnode-&gt;next=NULL;</span><br><span class="line">		printf(&quot;producer=[%d],data=[%d]\n&quot;,no,pnode-&gt;data);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);	//注意先解锁，再通知消费者解除阻塞！！！</span><br><span class="line">		pthread_cond_signal(&amp;cond);//唤醒消费者</span><br><span class="line">		sleep(rand()%2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//消费者线程</span><br><span class="line">void *consumer(void *arg)&#123;</span><br><span class="line">	int no=*(int *)arg;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		//消费头结点的下一个节点</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		</span><br><span class="line">		//注意需要循环判断（如果是if，后面会空指针错误），因为可能多个消费者阻塞再cond上！！！</span><br><span class="line">		while(dummy_head-&gt;next==NULL)&#123;//链表为空，生产者阻塞</span><br><span class="line">			pthread_cond_wait(&amp;cond,&amp;mutex);//若条件不满足，则阻塞等待并释放锁；若条件满足，则解除阻塞并加锁！！！</span><br><span class="line">		&#125;</span><br><span class="line">		Node *pnode=dummy_head-&gt;next;</span><br><span class="line">		dummy_head-&gt;next=pnode-&gt;next;</span><br><span class="line">		printf(&quot;consumer=[%d],data=[%d]\n&quot;,no,pnode-&gt;data);</span><br><span class="line">		free(pnode);</span><br><span class="line">		pnode=NULL;</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		sleep(rand()%2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	dummy_head=(Node *)malloc(sizeof(Node));</span><br><span class="line">	dummy_head-&gt;data=0;</span><br><span class="line">	dummy_head-&gt;next=NULL;</span><br><span class="line">	pthread_t pthread[4];</span><br><span class="line">	</span><br><span class="line">	pthread_mutex_init(&amp;mutex,NULL);</span><br><span class="line">	pthread_cond_init(&amp;cond,NULL);</span><br><span class="line">	int i,j;</span><br><span class="line">	for(i=0;i&lt;2;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int *t=(int *)malloc(sizeof(int));</span><br><span class="line">		*t=i;</span><br><span class="line">		pthread_create(&amp;pthread[i],NULL,producer,t);</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	for(j=2;j&lt;4;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		int *tt=(int *)malloc(sizeof(int));</span><br><span class="line">		*tt=j;</span><br><span class="line">		pthread_create(&amp;pthread[j],NULL,consumer,tt);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int k;</span><br><span class="line">	</span><br><span class="line">	for(k=0;k&lt;4;k++)</span><br><span class="line">		pthread_join(pthread[k],NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">	pthread_cond_destroy(&amp;cond);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">//信号量，只适用于单生产者，单消费者模型。</span><br><span class="line">//出现多消费者多生产者，会出错！</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;semaphore.h&gt;</span><br><span class="line">typedef struct node&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">//创建虚拟头结点</span><br><span class="line">Node *dummy_head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sem_t sem_produce;</span><br><span class="line">sem_t sem_consumer;</span><br><span class="line"></span><br><span class="line">//生产者线程</span><br><span class="line">void *producer(void *arg)&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	Node *p=NULL;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">	</span><br><span class="line">		//尾插法</span><br><span class="line">		sem_wait(&amp;sem_consumer);</span><br><span class="line">		Node *pnode=(Node *)malloc(sizeof(Node));</span><br><span class="line">		p=dummy_head;</span><br><span class="line">		pnode-&gt;data=rand()%1000;</span><br><span class="line">		</span><br><span class="line">		while(p-&gt;next!=NULL)&#123;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">		p-&gt;next=pnode;</span><br><span class="line">		pnode-&gt;next=NULL;</span><br><span class="line">		printf(&quot;producer,data=[%d]\n&quot;,pnode-&gt;data);</span><br><span class="line">		sem_post(&amp;sem_produce);</span><br><span class="line">		sleep(rand()%2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//消费者线程</span><br><span class="line">void *consumer(void *arg)&#123;</span><br><span class="line">	</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		//消费头结点的下一个节点</span><br><span class="line">		sem_wait(&amp;sem_produce);</span><br><span class="line">		</span><br><span class="line">		Node *pnode=dummy_head-&gt;next;</span><br><span class="line">		dummy_head-&gt;next=pnode-&gt;next;</span><br><span class="line">		printf(&quot;consumer,data=[%d]\n&quot;,pnode-&gt;data);</span><br><span class="line">		free(pnode);</span><br><span class="line">		pnode=NULL;</span><br><span class="line">		sem_post(&amp;sem_consumer);</span><br><span class="line">		sleep(rand()%2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	dummy_head=(Node *)malloc(sizeof(Node));</span><br><span class="line">	dummy_head-&gt;data=0;</span><br><span class="line">	dummy_head-&gt;next=NULL;</span><br><span class="line">	pthread_t pthread1,pthread2;</span><br><span class="line">	</span><br><span class="line">	sem_init(&amp;sem_consumer,0,5);//控制最多可以连续生产的数量</span><br><span class="line">	sem_init(&amp;sem_produce,0,0);</span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;pthread1,NULL,producer,NULL);</span><br><span class="line">	pthread_create(&amp;pthread2,NULL,consumer,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	pthread_join(pthread1,NULL);</span><br><span class="line">	pthread_join(pthread2,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	sem_destroy(&amp;sem_consumer);</span><br><span class="line">	sem_destroy(&amp;sem_produce);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/01/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/01/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">进程通信</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-01 18:09:32" itemprop="dateCreated datePublished" datetime="2022-05-01T18:09:32+08:00">2022-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-03 19:21:09" itemprop="dateModified" datetime="2022-05-03T19:21:09+08:00">2022-05-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#进程间通信（IPC：interprocess communication）的概念<br>进程都有自己独立的地址空间，不能通过全局变量进行通信，要想进行通信，必须通过内核！<br>一个进行将数据写到内核缓冲区，另一个进程将数据读走。</p>
<ul>
<li>现在常用的进程间的通信方式有：<br>（1）管道（使用最简单）<br>（2）信号（开销最小）<br>（3）共享映射区（无血缘关系）<br>（4）本地套接字（最稳定）</li>
</ul>
<h2 id="管道–pipe"><a href="#管道–pipe" class="headerlink" title="管道–pipe"></a>管道–pipe</h2><p>管道是一种最基本的IPC机制，应用于有血缘关系的进程之间，完成数据传递。<br>（1）管道的本质是一块内核缓冲区<br>（2）由两个文件描述符引用，一个表示读端，一个表示写端。<br>（3）规定数据从管道的写端流入管道，从读端流出。<br>（4）当两个进程都终结的时候，管道也自动消失。<br>（5）管道的读端和写端默认都是阻塞的.</p>
<ul>
<li>管道的原理<br>（1）实质是内核缓冲区，内部实现是循环队列<br>（2）默认缓冲区大小为4k，使用ulimit -a查看<br>（3）实际操作过程中的缓冲区会根据数据压力做适当调整</li>
<li>管道的局限性<br>（1）数据一旦被读走，便不在管道中存在，不可反复读取。<br>（2）数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道<br>（3）只能在有血缘关系的进程间使用管道。</li>
</ul>
<h2 id="补充知识：指针类型的变量，是来存放地址的，那么它当然等于计算机内部地址总线的宽度。所以在32位计算机中，一个指针变量的返回值必定是4（注意结果是以字节为单位，在64位系统中指针变量的sizeof结果为8。"><a href="#补充知识：指针类型的变量，是来存放地址的，那么它当然等于计算机内部地址总线的宽度。所以在32位计算机中，一个指针变量的返回值必定是4（注意结果是以字节为单位，在64位系统中指针变量的sizeof结果为8。" class="headerlink" title="补充知识：指针类型的变量，是来存放地址的，那么它当然等于计算机内部地址总线的宽度。所以在32位计算机中，一个指针变量的返回值必定是4（注意结果是以字节为单位，在64位系统中指针变量的sizeof结果为8。"></a>补充知识：指针类型的变量，是来存放地址的，那么它当然等于计算机内部地址总线的宽度。所以在32位计算机中，一个指针变量的返回值必定是4（注意结果是以字节为单位，在64位系统中指针变量的sizeof结果为8。</h2><h2 id="pipe用于父子进程间的通信过程"><a href="#pipe用于父子进程间的通信过程" class="headerlink" title="pipe用于父子进程间的通信过程"></a>pipe用于父子进程间的通信过程</h2><p>(1)父进程创建pipe<br>(2)父进程调用fork函数创建子进程<br>(3)父进程关闭一端（读&#x2F;写），子进程关闭另一端（写&#x2F;读）。<br>(4)父子进程分别执行read和write函数<br>注意：如果都要读&#x2F;写，则需要创建两个pipe!!!</p>
<h2 id="ps-aux-grep-bash的实现原理-pipe的应用"><a href="#ps-aux-grep-bash的实现原理-pipe的应用" class="headerlink" title="ps aux|grep bash的实现原理(pipe的应用)"></a>ps aux|grep bash的实现原理(pipe的应用)</h2><p><img src="/images/ps_aux.png"></p>
<ul>
<li>父子通信</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int fd[2];</span><br><span class="line">	int ret=pipe(fd);</span><br><span class="line">	if(ret==-1)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;pipe error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	pid_t pid=fork();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	if(pid&gt;0)&#123;</span><br><span class="line">		close(fd[0]);//关闭读</span><br><span class="line">		int res=dup2(fd[1],STDOUT_FILENO);//标准输出重定向</span><br><span class="line">		if(res==-1)&#123;</span><br><span class="line">			perror(&quot;dup2 error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;aux&quot;,NULL);//拉起一个应用程序，直接替换代码段，成功执行后，该语句后面的不会执行。</span><br><span class="line">		perror(&quot;execlp error&quot;);</span><br><span class="line">		wait(NULL);//阻塞回收子进程，当execlp执行失败，则会执行</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid==0)&#123;</span><br><span class="line">		close(fd[1]);//关闭写</span><br><span class="line">		int re=dup2(fd[0],STDIN_FILENO);</span><br><span class="line">		if(re==-1)&#123;</span><br><span class="line">			perror(&quot;dup2 error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		execlp(&quot;grep&quot;,&quot;grep&quot;,&quot;--color=auto&quot;,&quot;bash&quot;,NULL);</span><br><span class="line">		perror(&quot;execlp error&quot;);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>兄弟通信</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int fd[2];</span><br><span class="line">	int ret=pipe(fd);</span><br><span class="line">	if(ret==-1)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;pipe error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0;i&lt;2;i++)&#123;</span><br><span class="line">		pid_t pid=fork();	</span><br><span class="line">		if(pid&lt;0)&#123;</span><br><span class="line">			perror(&quot;fork error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(pid&gt;0)&#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(pid==0)&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(i==2)&#123;</span><br><span class="line">		close(fd[0]);//父进程关闭读写，只用于回收子进程</span><br><span class="line">		close(fd[1]);</span><br><span class="line">		while(1)&#123;</span><br><span class="line">			pid_t wpid=waitpid(-1,NULL,WNOHANG);</span><br><span class="line">			if(wpid==0)</span><br><span class="line">				continue;</span><br><span class="line">			else if(wpid==-1)//无子进程了，退出</span><br><span class="line">				exit(0);</span><br><span class="line">			else if(wpid&gt;0)&#123;</span><br><span class="line">				printf(&quot;recover child pid=[%d]\n&quot;,wpid);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	if(i==0)&#123;</span><br><span class="line">		printf(&quot;child 1,pid=[%d],ppid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">		close(fd[0]);</span><br><span class="line">		int ret=dup2(fd[1],STDOUT_FILENO);</span><br><span class="line">		if(ret==-1)&#123;</span><br><span class="line">			perror(&quot;dup2 error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;aux&quot;,NULL);</span><br><span class="line">		perror(&quot;execlp error&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	if(i==1)&#123;</span><br><span class="line">		printf(&quot;child 2,pid=[%d],ppid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">		close(fd[1]);</span><br><span class="line">		int res=dup2(fd[0],STDIN_FILENO);</span><br><span class="line">		if(res==-1)&#123;</span><br><span class="line">			perror(&quot;dup2 error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		execlp(&quot;grep&quot;,&quot;grep&quot;,&quot;bash&quot;,NULL);</span><br><span class="line">		perror(&quot;execlp error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#FIFO</p>
<ul>
<li><p>FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间通信。但通过FIFO，不相关的进程也能交换数据.</p>
</li>
<li><p>fifo进程通信原理<br><img src="/images/fifo.png"></p>
</li>
<li><p>fifo完成两个进程间的通信思路<br>进程A：<br>（1）创建一个fifo文件：mkfifo命令或者使用mkfifo函数。<br>（2）open fifo文件，获得一个文件描述符。<br>（3）写fifo文件<br>（4）关闭fifo文件<br>进程B：<br>（1）打开fifo文件，获得文件描述符。<br>（2）读fifo文件<br>（3）关闭fifo文件</p>
</li>
<li><p>注意：使用open打开FIFO文件</p>
</li>
</ul>
<p>1.FIFO命名管道不能以O_RDWR的模式打开，会产生二义性。（通常使用FIFO只是为了单向传递数据）</p>
<p>2.如果确定需要程序之间双向传递数据。<br>①最好使用一对FIFO或者管道，一个方向使用一个！！！<br>②采用先关闭再重新打开FIFO的方法来明确地改变数据流的去向（不常用）。</p>
<h3 id="只写阻塞方式打开fifo文件，在写入数据时，若没有进程在另一端读，则阻塞，直至有进程读。"><a href="#只写阻塞方式打开fifo文件，在写入数据时，若没有进程在另一端读，则阻塞，直至有进程读。" class="headerlink" title="只写阻塞方式打开fifo文件，在写入数据时，若没有进程在另一端读，则阻塞，直至有进程读。"></a>只写阻塞方式打开fifo文件，在写入数据时，若没有进程在另一端读，则阻塞，直至有进程读。</h3><p>通过两个fifo文件，实现两个进程之间的相互读写（阻塞方式）。</p>
<ul>
<li>进程A：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//fifo完成进程间通信的测试</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">		//创建fifo文件</span><br><span class="line">	int res=access(&quot;./myfifo_2&quot;,F_OK);//测试文件是否存在,返回0存在</span><br><span class="line">	if(res!=0)&#123;</span><br><span class="line">		int ret=mkfifo(&quot;./myfifo_2&quot;,0777);</span><br><span class="line">		if(ret==-1)&#123;</span><br><span class="line">			perror(&quot;mkfifo error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int fd1=open(&quot;./myfifo&quot;,O_RDONLY);</span><br><span class="line">	int fd2=open(&quot;./myfifo_2&quot;,O_WRONLY);</span><br><span class="line">	if(fd1&lt;0||fd2&lt;0)&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//读myfifo文件</span><br><span class="line">	char buf[256];</span><br><span class="line">	memset(buf,0x00,sizeof(buf));</span><br><span class="line">	int len=read(fd1,buf,sizeof(buf));</span><br><span class="line">	printf(&quot;len=[%d],buf=[%s]\n&quot;,len,buf);</span><br><span class="line">	close(fd1);</span><br><span class="line">	//写myfifo_2文件</span><br><span class="line">	write(fd2,&quot;ni hao&quot;,sizeof(&quot;ni hao&quot;));</span><br><span class="line">	close(fd2);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>进程B</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//fifo完成进程间通信的测试</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//创建fifo文件</span><br><span class="line">	int res=access(&quot;./myfifo&quot;,F_OK);//测试文件是否存在,返回0存在</span><br><span class="line">	if(res!=0)&#123;</span><br><span class="line">		int ret=mkfifo(&quot;./myfifo&quot;,0777);</span><br><span class="line">		if(ret==-1)&#123;</span><br><span class="line">			perror(&quot;mkfifo error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	int fd1=open(&quot;./myfifo&quot;,O_WRONLY);</span><br><span class="line">	int fd2=open(&quot;./myfifo_2&quot;,O_RDONLY);</span><br><span class="line">	if(fd1&lt;0||fd2&lt;0)&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//写myfifo文件</span><br><span class="line">	write(fd1,&quot;hello world&quot;,strlen(&quot;hello world&quot;));</span><br><span class="line">	close(fd1);</span><br><span class="line">	</span><br><span class="line">	//读myfifo_2文件</span><br><span class="line">	char buf[256];</span><br><span class="line">	memset(buf,0x00,sizeof(buf));</span><br><span class="line">	int len=read(fd2,buf,sizeof(buf));</span><br><span class="line">	printf(&quot;len=[%d],buf=[%s]\n&quot;,len,buf);</span><br><span class="line">	close(fd2);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="共享映射区"><a href="#共享映射区" class="headerlink" title="共享映射区"></a>共享映射区</h1><ul>
<li><p>存储映射I&#x2F;O (Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样，就可在不使用read和write函数的情况下，使用地址（指针）完成I&#x2F;O操作<br><img src="/images/mmap.png"></p>
</li>
<li><p>函数原型：<br>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);<br>参数：<br>addr:一般传NULL,表示让内核去指定一个内存的起始地址<br>length:文件大小（lseek或者stat函数获取）<br>prot:PROT_READ;PROT_WRITE;PROT_READ|PROT_WRITE<br>flags:<br>MAP_SHARED:对映射区的修改会反映到文件中（可以对文件进行修改).<br>MAP_PRIVATE:可以读文件中的数据，但是写不进去数据，即使向内存中也写不进去数据。<br>fd:打开的文件描述符<br>offset:从文件的哪个位置开始映射，一般为0.<br>返回值：映射区的首地址。</p>
</li>
<li><p>实现父子进程之间的通信</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//利用mmap函数完成父子进程间通信</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//使用mmap函数建立共享映射区</span><br><span class="line">	//void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="line">	int fd=open(&quot;./test.log&quot;,O_RDWR);</span><br><span class="line">	if(fd&lt;0)&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	int len=lseek(fd,0,SEEK_END);//获取文件大小</span><br><span class="line"></span><br><span class="line">	//void *addr=mmap(NULL,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</span><br><span class="line">	void *addr=mmap(NULL,len,PROT_READ|PROT_WRITE,MAP_PRIVATE,fd,0);</span><br><span class="line">	if(addr==MAP_FAILED)&#123;</span><br><span class="line">		perror(&quot;mmap error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	pid_t pid=fork();</span><br><span class="line">	if(pid&lt;0)&#123;</span><br><span class="line">		perror(&quot;fork error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid&gt;0)&#123;</span><br><span class="line">		memcpy(addr,&quot;hello world&quot;,strlen(&quot;hello world&quot;));//设置为MAP_PRIVATE,向内存中写不进去数据</span><br><span class="line">		wait(NULL);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid==0)&#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">		char *p=(char *)addr;//可以读文件中的数据</span><br><span class="line">		printf(&quot;[%s]\n&quot;,p);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>实现无血缘关系的进程之间的通信</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//利用mmap函数完成进程间通信(write)</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//使用mmap函数建立共享映射区</span><br><span class="line">	//void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="line">	int fd=open(&quot;./test.log&quot;,O_RDWR);</span><br><span class="line">	if(fd&lt;0)&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	int len=lseek(fd,0,SEEK_END);//获取文件大小</span><br><span class="line"></span><br><span class="line">	void *addr=mmap(NULL,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</span><br><span class="line">	</span><br><span class="line">	if(addr==MAP_FAILED)&#123;</span><br><span class="line">		perror(&quot;mmap error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	memcpy(addr,&quot;0123456789&quot;,10);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//利用mmap函数完成进程间通信(read)</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//使用mmap函数建立共享映射区</span><br><span class="line">	//void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="line">	int fd=open(&quot;./test.log&quot;,O_RDWR);</span><br><span class="line">	if(fd&lt;0)&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	int len=lseek(fd,0,SEEK_END);//获取文件大小</span><br><span class="line"></span><br><span class="line">	void *addr=mmap(NULL,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</span><br><span class="line">	</span><br><span class="line">	if(addr==MAP_FAILED)&#123;</span><br><span class="line">		perror(&quot;mmap error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	char buf[64];</span><br><span class="line">	memset(buf,0x00,sizeof(buf));</span><br><span class="line">	memcpy(buf,addr,10);</span><br><span class="line">	printf(&quot;buf=[%s]\n&quot;,buf);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>使用mmap函数建立匿名映射(只能用与有血缘关系的进程)：<br>mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</li>
</ul>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><ul>
<li><p>每个进程收到的所有信号，都是由内核负责发送的。<br>进程A给进程B发送信号原理示意图：<br><img src="/images/mmap.png"></p>
</li>
<li><p>signal函数使用</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void sighandler(int signo)&#123;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;signo=[%d]\n&quot;,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	int fd[2];</span><br><span class="line">	int ret=pipe(fd);</span><br><span class="line">	if(ret&lt;0)&#123;</span><br><span class="line">		perror(&quot;pipe error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//注册信号处理函数，当触发SIGPIPE信号时，内核就会回调用户定义好的回调函数，执行回调函数的内容</span><br><span class="line">	signal(SIGPIPE,sighandler);</span><br><span class="line">	</span><br><span class="line">	close(fd[0]);//关闭读端</span><br><span class="line">	write(fd[1],&quot;1213&quot;,strlen(&quot;1213&quot;));//往管道里写数据，因为没有读端，系统会发送一个SIGPIPE信号</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>信号的特点：简单，不挟带大量信息，满足某个特定条件产生</p>
</li>
<li><p>信号的产生: 按键（Ctrl+c、Ctrl+z、Ctrl+\）；系统调用。。。</p>
</li>
<li><p>信号的状态: 产生，未决，递达</p>
</li>
<li><p>信号的四要素：<br>信号的编号<br>信号的名字<br>信号的默认处理动作<br>信号是如何产生的（产生原因）</p>
</li>
<li><p>signal函数: 给内核注册信号处理函数</p>
</li>
<li><p>kill: 发送指定信号给指定进程<br>kill函数原型：int kill(pid_t pid, int sig);<br>函数返回值：<br>成功：0；<br>失败：-1，设置errno</p>
</li>
</ul>
<h3 id="特别需要注意的是：The-signals-SIGKILL-and-SIGSTOP-cannot-be-caught-blocked-or-ignored"><a href="#特别需要注意的是：The-signals-SIGKILL-and-SIGSTOP-cannot-be-caught-blocked-or-ignored" class="headerlink" title="特别需要注意的是：The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored."></a>特别需要注意的是：The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</h3><h3 id="几个常用到的信号"><a href="#几个常用到的信号" class="headerlink" title="几个常用到的信号"></a>几个常用到的信号</h3><p>SIGINT、SIGQUIT、SIGKILL、SIGSEGV、SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM、SIGTERM、SIGCHLD、SIGSTOP、SIGCONT</p>
<ul>
<li><p>alarm:<br>  1 每一个进程都只有一个时钟，后一个的时钟设置会覆盖上一个时钟！！！<br>  2 alarm函数的返回值: 0 或者是上一个alarm剩余的秒数<br>  3 alarm(0): 取消定时器<br>  4 alarm函数发送的是SIGALRM信号，作用是term，终止进程.</p>
</li>
<li><p>使用time命令查看程序执行的时间。程序运行的瓶颈在于IO，优化程序，首选优化IO。</p>
</li>
<li><p>实际执行时间 &#x3D; 系统时间 + 用户时间 + 损耗时间<br>损耗的时间主要来来自文件IO操作，IO操作会有用户区到内核区的切换，切换的次数越多越耗时。</p>
</li>
</ul>
<h2 id="闹钟"><a href="#闹钟" class="headerlink" title="闹钟"></a>闹钟</h2><ul>
<li><p>实际执行时间 &#x3D; 系统时间 + 用户时间 + 损耗时间</p>
</li>
<li><p>损耗时间&#x3D; 实际执行时间-(系统时间 + 用户时间 )</p>
</li>
<li><p>每一个数字都直接打印:printf(“[%d]\n”, i++);<br>real    0m1.217s<br>user    0m0.120s<br>sys     0m0.252s<br>15734次<br>损耗时间&#x3D; 1.217-(0.120+0.252)&#x3D;0.845</p>
</li>
<li><p>文件重定向之后:<br>time .&#x2F;alarm_uncle  &gt; test.log<br>real    0m1.003s<br>user    0m0.520s<br>sys     0m0.428s<br>2191879次<br>损耗时间&#x3D;1.003-(0.520+0.428)&#x3D;0.055</p>
</li>
<li><p>原因是: 调用printf函数打印数字遇到\n才会打印, 打印过程涉及到从用户区到内核区的切换, 切换次数越多消耗的时间越长, 效率越低;而使用文件重定向, 由于文件操作是带缓冲的, 所以涉及到用户区到内核区的<br>切换次数大大减少,从而使损耗降低.</p>
</li>
<li><p>setitimer函数的功能: 设置时钟, 能够周期性的触发时钟<br>int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);</p>
</li>
<li><p>使用setitimer实现从第三秒开始，每隔一秒打印一次signo。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//setitimer函数测试</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">void sighander(int signo)&#123;</span><br><span class="line">	printf(&quot;signo=[%d]\n&quot;,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	 //int setitimer(int which, const struct itimerval *new_value,</span><br><span class="line">       //              struct itimerval *old_value);</span><br><span class="line">	</span><br><span class="line">	//注册信号处理函数</span><br><span class="line">	signal(SIGALRM,sighander);</span><br><span class="line">	</span><br><span class="line">	struct itimerval tm;</span><br><span class="line">	//周期性时间赋值</span><br><span class="line">	tm.it_interval.tv_sec=1;//秒</span><br><span class="line">	tm.it_interval.tv_usec=0;//微秒</span><br><span class="line">	//第一次触发的时间</span><br><span class="line">	tm.it_value.tv_sec=3;</span><br><span class="line">	tm.it_value.tv_usec=0;</span><br><span class="line">	</span><br><span class="line">	setitimer(ITIMER_REAL,&amp;tm,NULL);</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><ul>
<li>未决信号集和阻塞信号集<br><img src="/images/sigset.png"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//每隔十次解除对SIGINT和SIGQUIT的阻塞，就能捕获到这两个信号，执行回调函数</span><br><span class="line">//信号集</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void sighander(int signo)&#123;</span><br><span class="line">	printf(&quot;signo=[%d]\n&quot;,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	signal(SIGINT,sighander);</span><br><span class="line">	signal(SIGQUIT,sighander);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//定义信号集变量</span><br><span class="line">	sigset_t set;</span><br><span class="line">	sigset_t oldset;</span><br><span class="line">	</span><br><span class="line">	//初始化信号集</span><br><span class="line">	sigemptyset(&amp;set);</span><br><span class="line">	sigemptyset(&amp;oldset);</span><br><span class="line">	</span><br><span class="line">	//将SIGINT(ctrl+c)和SIGQUIT(ctrl+\)加入到集合中</span><br><span class="line">	sigaddset(&amp;set,SIGINT);</span><br><span class="line">	sigaddset(&amp;set,SIGQUIT);</span><br><span class="line">	</span><br><span class="line">	//将SIGINT和SIGQUIT加入到阻塞集中</span><br><span class="line">	//int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="line">	sigprocmask(SIG_BLOCK,&amp;set,&amp;oldset);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	sigset_t pending;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	int j=0;</span><br><span class="line">	</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		</span><br><span class="line">		sigemptyset(&amp;pending);//初始化</span><br><span class="line">		</span><br><span class="line">		//获取未决信号集</span><br><span class="line">		sigpending(&amp;pending);</span><br><span class="line">		int i;</span><br><span class="line">		for(i=1;i&lt;32;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(sigismember(&amp;pending,i)==1)</span><br><span class="line">				printf(&quot;1&quot;);</span><br><span class="line">			else</span><br><span class="line">				printf(&quot;0&quot;);</span><br><span class="line">				</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		sleep(1);</span><br><span class="line">		j++;</span><br><span class="line">		//每循环10次，就解除一次对SIGINT和SIGQUIT的阻塞</span><br><span class="line">		if(j%10==0)&#123;</span><br><span class="line">			//sigprocmask(SIG_UNBLOCK,&amp;set,NULL);</span><br><span class="line">			sigprocmask(SIG_SETMASK,&amp;oldset,NULL);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			sigprocmask(SIG_BLOCK,&amp;set,NULL);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号捕捉函数"><a href="#信号捕捉函数" class="headerlink" title="信号捕捉函数"></a>信号捕捉函数</h2><ul>
<li><p>在xxx信号处理函数执行期间, 若xxx信号再次产生多次, 则信号处理函数不会被打断,当信号处理函数执行完以后, 后来产生的信号只会被处理一次.<br>信号不支持排队.  </p>
</li>
<li><p>在xxx信号处理函数执行期间(前提是sa_mask中阻塞了yyy信号), 若收到了yyy信号, 则yyy信号会被阻塞(暂时被阻塞（和阻塞集无关）！！！), 当xxx信号处理函数执行完毕后, 则yyy信号只会被处理一次.</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void sighandler(int signo)&#123;</span><br><span class="line">	printf(&quot;signo=-[%d]\n&quot;,signo);</span><br><span class="line">	sleep(3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	//注册信号处理函数</span><br><span class="line">	struct sigaction act;</span><br><span class="line">	act.sa_handler=sighandler;//信号处理函数</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);//阻塞的信号</span><br><span class="line">	//sigaddset(&amp;act.sa_mask,SIGQUIT);//在信号处理函数执行期间阻塞SIGQUIT信号</span><br><span class="line">	act.sa_flags=0;</span><br><span class="line">	sigaction(SIGINT,&amp;act,NULL);</span><br><span class="line">	</span><br><span class="line">	signal(SIGQUIT,sighandler);</span><br><span class="line">	</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SIGCHLD信号（重点！！！注意理解）"><a href="#SIGCHLD信号（重点！！！注意理解）" class="headerlink" title="SIGCHLD信号（重点！！！注意理解）"></a>SIGCHLD信号（重点！！！注意理解）</h2><ul>
<li>SIGCHLD信号:</li>
</ul>
<p>1 SIGCHLD信号产生的条件:<br>（1）子进程收到SIGSTOP；<br>（2）子进程收到SIGCONT；<br>（3）子进程退出   </p>
<p>2 SIGCHLD信号的作用:子进程退出之后, 内核会给其父进程发送SIGCHLD信号, 父进程收到这个信号之后, 调用waitpid或者wait完成对子进程的回收.</p>
<ul>
<li>核心代码（父进程回收子进程）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">//父进程使用SIGCHLD信号完成对子进程的回收</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">void waitchild(int signo)&#123;</span><br><span class="line">	</span><br><span class="line">	pid_t wpid;</span><br><span class="line">	//当有子进程死掉之后，就会执行该回调函数，循环回收子进程，直至无子进程或者只剩下正在执行的子进程时，跳出循环，结束该函数。</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		wpid=waitpid(-1,NULL,WNOHANG);//一次只能回收一个子进程，-1代表可以回收任意子进程</span><br><span class="line">		if(wpid&gt;0)&#123;//回收到子进程</span><br><span class="line">			printf(&quot;child is quit,wpid=[%d]\n&quot;,wpid);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(wpid==0)&#123;//当前有正在运行的子进程，退出回收</span><br><span class="line">			printf(&quot;child is living,wpid=[%d]\n&quot;,wpid);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(wpid==-1)&#123;//无子进程了，退出回收</span><br><span class="line">				printf(&quot;no child,wpid=[%d]\n&quot;,wpid);</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	int i=0;</span><br><span class="line">	//将SIGCHLD信号阻塞</span><br><span class="line">	sigset_t mask;</span><br><span class="line">	sigaddset(&amp;mask,SIGCHLD);</span><br><span class="line">	sigprocmask(SIG_BLOCK,&amp;mask,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">for(;i&lt;3;i++)&#123;</span><br><span class="line">	//创建子进程</span><br><span class="line">//	printf(&quot;before fork, pid=[%d]\n&quot;,getpid());</span><br><span class="line">	pid_t pid=fork();</span><br><span class="line">	if(pid&lt;0)&#123;</span><br><span class="line">		perror(&quot;error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid&gt;0)&#123; //父进程</span><br><span class="line">		printf(&quot;father: pid=[%d],fpid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid==0)&#123;  //子进程</span><br><span class="line">		printf(&quot;child :pid=[%d],fpid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">		break;		</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">if(i==0)&#123;</span><br><span class="line">	printf(&quot;[%d]--[%d]:child\n&quot;,i,getpid());</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">else if(i==1)&#123;</span><br><span class="line">	printf(&quot;[%d]--[%d]:child\n&quot;,i,getpid());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else if(i==2)&#123;</span><br><span class="line"> printf(&quot;[%d]--[%d]:child\n&quot;,i,getpid());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">else if(i==3)</span><br><span class="line">&#123;</span><br><span class="line">	//注册信号处理函数</span><br><span class="line">	struct sigaction act;</span><br><span class="line">	act.sa_handler=waitchild;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	act.sa_flags=0;</span><br><span class="line">	</span><br><span class="line">	sleep(5);</span><br><span class="line">	sigaction(SIGCHLD,&amp;act,NULL);</span><br><span class="line">	</span><br><span class="line">	//解除对SIGCHLD阻塞</span><br><span class="line">	sigprocmask(SIG_UNBLOCK,&amp;mask,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//父进程执行其他操作</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码解释：</p>
<ul>
<li><p>问题一：有可能还没有完成对SIGCHLD信号的注册, 三个子进程就全部退出了.<br>解决方法: 在fork之前先将SIGCHLD信号阻塞,阻塞之后不管来多少个SIGCHLD信号，最终在未决集中只存在的是SIGCHLD为1，表示未处理的信号，然后在完成对SIGCHLD信号的注册之后再解除对SIGCHLD信号的阻塞;</p>
</li>
<li><p>问题二：有可能在SIGCHLD信号处理函数执行期间, 另外的2个子进程同时全部退出, 由于信号是不支持排队的，此时来的信号会被阻塞，在信号处理函数结束之后，只会保留一个信号，所以，还会处理回收一个子进程，此时另一个会成为僵尸进程.<br>解决办法: 在信号处理函数中应该循环回收, 当waitpid返回-1的时候就表示已经回收完所有子进程了, 此时可以break;    </p>
</li>
<li><p>内核实现信号捕捉的过程</p>
</li>
</ul>
<p><img src="/images/signal_process.png"></p>
<ul>
<li>正常情况下，不用信号完成进程间的通信！！！</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">进程控制</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-26 20:01:28" itemprop="dateCreated datePublished" datetime="2022-04-26T20:01:28+08:00">2022-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-01 11:54:36" itemprop="dateModified" datetime="2022-05-01T11:54:36+08:00">2022-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="程序和进程的概念"><a href="#程序和进程的概念" class="headerlink" title="程序和进程的概念:"></a>程序和进程的概念:</h1><p>程序: 是编译好的二进制文件, 存放在磁盘上, 占用的是磁盘空间, 是一个静态的概念.<br>进程: 一个启动的程序, 需要占用系统资源: 如 内存, cpu 终端 等<br>剧本—&gt;程序<br>进程—&gt;唱戏(舞台, 灯光, 道具, 人等资源)<br>同一个程序可以在多个终端执行, 类似与同一台戏可以在多个舞台演出.<br>每启动一个程序都会有一个进程PID, 即使是相同的程序多次启动也会有个不同的PID。</p>
<h1 id="并发和并行的概念"><a href="#并发和并行的概念" class="headerlink" title="并发和并行的概念"></a>并发和并行的概念</h1><p>并发: 在一个时间段内, 一个CPU上, 有多个程序在执行.<br>并行: 并行指两个或两个以上的程序在同一时刻发生(需要有多核)。<br>cpu会将一个大的时间段分成多个小的时间片, 让进程轮流使用CPU的时间片.<br>#进程的五态模型和七态模型</p>
<p>#进程创建</p>
<ul>
<li>调用fork函数的内核实现原理:<br><img src="/images/fork.png"><br><img src="/images/fork_two.png"></li>
</ul>
<h2 id="循环创建子进程问题（子进程也会创建子进程）："><a href="#循环创建子进程问题（子进程也会创建子进程）：" class="headerlink" title="循环创建子进程问题（子进程也会创建子进程）："></a>循环创建子进程问题（子进程也会创建子进程）：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> 1 //fork函数测试，循环创建子进程</span><br><span class="line"> 2 #include&lt;stdio.h&gt;</span><br><span class="line"> 3 #include&lt;stdlib.h&gt;</span><br><span class="line"> 4 #include&lt;string.h&gt;</span><br><span class="line"> 5 #include&lt;sys/types.h&gt;</span><br><span class="line"> 6 #include&lt;unistd.h&gt;</span><br><span class="line"> 7</span><br><span class="line"> 8 int main()&#123;</span><br><span class="line"> 9</span><br><span class="line">10     int i=0;</span><br><span class="line">11 for(;i&lt;3;i++)&#123;</span><br><span class="line">12     //创建子进程</span><br><span class="line">13     printf(&quot;before fork, pid=[%d]\n&quot;,getpid());</span><br><span class="line">14     pid_t pid=fork();</span><br><span class="line">15     if(pid&lt;0)&#123;</span><br><span class="line">16         perror(&quot;error&quot;);</span><br><span class="line">17         return -1;</span><br><span class="line">18     &#125;</span><br><span class="line">19     else if(pid&gt;0)&#123; //父进程</span><br><span class="line">20         printf(&quot;father: pid=[%d],fpid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">21     //  sleep(1);</span><br><span class="line">22     &#125;</span><br><span class="line">23     else if(pid==0)&#123;  //子进程</span><br><span class="line">24         printf(&quot;child :pid=[%d],fpid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">25</span><br><span class="line">26         &#125;</span><br><span class="line">27     printf(&quot;after fork, pid=[%d]\n&quot;,getpid());</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31     &#125;</span><br><span class="line">32 return 0;</span><br><span class="line">33 &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主进程总共创建了7个子进程，分析如下：<br><img src="/images/child_fork.png"></p>
<h2 id="修该后的代码"><a href="#修该后的代码" class="headerlink" title="修该后的代码"></a>修该后的代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> 1 //fork函数测试，循环创建子进程</span><br><span class="line"> 2 #include&lt;stdio.h&gt;</span><br><span class="line"> 3 #include&lt;stdlib.h&gt;</span><br><span class="line"> 4 #include&lt;string.h&gt;</span><br><span class="line"> 5 #include&lt;sys/types.h&gt;</span><br><span class="line"> 6 #include&lt;unistd.h&gt;</span><br><span class="line"> 7</span><br><span class="line"> 8 int main()&#123;</span><br><span class="line"> 9</span><br><span class="line">10     int i=0;</span><br><span class="line">11 for(;i&lt;3;i++)&#123;</span><br><span class="line">12     //创建子进程</span><br><span class="line">13     printf(&quot;before fork, pid=[%d]\n&quot;,getpid());</span><br><span class="line">14     pid_t pid=fork();</span><br><span class="line">15     if(pid&lt;0)&#123;</span><br><span class="line">16         perror(&quot;error&quot;);</span><br><span class="line">17         return -1;</span><br><span class="line">18     &#125;</span><br><span class="line">19     else if(pid&gt;0)&#123; //父进程</span><br><span class="line">20         printf(&quot;father: pid=[%d],fpid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">21     //  sleep(1);</span><br><span class="line">22     &#125;</span><br><span class="line">23     else if(pid==0)&#123;  //子进程</span><br><span class="line">24         printf(&quot;child :pid=[%d],fpid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">25         break;//只要子进程在此处跳出循环即可！！！</span><br><span class="line">26         &#125;</span><br><span class="line">27     printf(&quot;after fork, pid=[%d]\n&quot;,getpid());</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31     &#125;</span><br><span class="line">32 return 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只要在子进程代码块中，执行完逻辑后，break出循环就能保证子进程不在创建子进程！！！</p>
<h1 id="父子进程不能共享全局变量（即不能够使用全局变量进行通信！！！）"><a href="#父子进程不能共享全局变量（即不能够使用全局变量进行通信！！！）" class="headerlink" title="父子进程不能共享全局变量（即不能够使用全局变量进行通信！！！）"></a>父子进程不能共享全局变量（即不能够使用全局变量进行通信！！！）</h1><p><img src="/images/global.png"><br>父子进程不能共享全局变量；但是如果父子进程只是对全局变量做读操作，则父子进程在真正的物理内存空间中只有一份，属于共享！但是如果父子进程中的任何一个进程对该变量进行修改操作，会在内存中拷贝一个副本，然后在这个副本上进行修改，修改完成后在映射回虚拟内存空间上去！！！</p>
<ul>
<li><p>总结：写时复制，读时共享！！！</p>
</li>
<li><p>如果想在一个进程内部执行系统命令或者是应用程序, 优先应该想到如下方式:<br>先fork(), 然后在子进程里面执行execl拉起可执行程序或者命令.<br>pid &#x3D; fork();<br>if(pid&#x3D;&#x3D;0)<br>{<br>  execl(…);<br>}</p>
</li>
</ul>
<p>execl: 一般用于执行用户自定义的应用程序.<br>execlp: 一般用于执行系统命令</p>
<ul>
<li><p>exec函数是用一个新程序替换了当前进程的代码段、数据段、堆和栈；原有的进程空间没有发生变化，并没有创建新的进程，进程PID没有发生变化。<br><img src="/images/excel.png"></p>
</li>
<li><p>为什么要对进程资源进行回收？<br>当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB资源，必须由它的父进程调用wait或者waitpid函数完成对子进程的回收，避免造成系统资源的浪费</p>
</li>
<li><p>孤儿进程<br>父进程先退出，子进程就变成了孤儿进程，此时被init进程领养，当孤儿进程退出后，就会被init进程回收。</p>
</li>
<li><p>僵尸进程<br>子进程先退出，父进程没有完成子进程的回收，此时子进程就变成了僵尸进程。<br>如何解决？<br>不能用kill -9杀死僵尸进程，因为僵尸进程是一个死掉的进程，无法接收信号，<br>应该使用杀死僵尸进程的父进程的方法来解决僵尸进程。<br>原因：杀死其父进程可以让init进程领养僵尸进程，最后init进程回收僵尸进程。</p>
</li>
<li><p>wait函数</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wait函数:</span><br><span class="line">	pid_t wait(int *status);</span><br><span class="line">	返回值:</span><br><span class="line">		&gt;0: 回收的子进程的PID</span><br><span class="line">		-1: 没有子进程</span><br><span class="line">	参数(man 2 wait查看宏定义！):</span><br><span class="line">		status: 子进程的退出状态</span><br><span class="line">			if(WIFEXITED(status))  //正常退出</span><br><span class="line">			&#123;</span><br><span class="line">				WEXITSTATUS(status) //返回退出状态（子进程的返回值）</span><br><span class="line">			&#125;</span><br><span class="line">			else if(WIFSIGNALED(status))//被信号杀死</span><br><span class="line">			&#123;</span><br><span class="line">				WTERMSIG(status) //返回信号的number</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>waitpid函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid,int *status,int options);</span><br><span class="line">参数：</span><br><span class="line">pid</span><br><span class="line">pid&gt;0,表示等待指定的子进程</span><br><span class="line">pid=-1:表示等待任意的子进程</span><br><span class="line">status</span><br><span class="line">同wait函数</span><br><span class="line">options</span><br><span class="line">0：表示阻塞</span><br><span class="line">WNOHANG:表示非阻塞</span><br><span class="line">返回值</span><br><span class="line">&gt;0:表示回收子进程的pid</span><br><span class="line">=0：若是非阻塞的，表示子进程还活着</span><br><span class="line">=-1：表示没有子进程了</span><br><span class="line"></span><br><span class="line">注意：调用一次waitpid或wait函数只能回收一个子进程</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/24/%E6%96%87%E4%BB%B6IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/24/%E6%96%87%E4%BB%B6IO/" class="post-title-link" itemprop="url">文件IO</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-24 10:57:59" itemprop="dateCreated datePublished" datetime="2022-04-24T10:57:59+08:00">2022-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-29 21:38:36" itemprop="dateModified" datetime="2022-04-29T21:38:36+08:00">2022-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C库IO函数的工作流程："><a href="#C库IO函数的工作流程：" class="headerlink" title="C库IO函数的工作流程："></a>C库IO函数的工作流程：</h1><p><img src="/images/file.png"></p>
<p><img src="/images/file1.png"></p>
<ul>
<li>使用fopen函数打开一个文件, 返回一个FILE* fp, 这个指针指向的结构体有三个重要的成员.<br>（1）文件描述符: 通过文件描述可以找到文件的inode, 通过inode可以找到对应的数据块<br>（2）文件指针: 读和写共享一个文件指针, 读或者写都会引起文件指针的变化<br>（3）文件缓冲区: 读或者写会先通过文件缓冲区, 主要目的是为了减少对磁盘的读写次数, 提高读写磁盘的效率.</li>
</ul>
<h1 id="C库函数和系统函数的关系（printf举例）"><a href="#C库函数和系统函数的关系（printf举例）" class="headerlink" title="C库函数和系统函数的关系（printf举例）"></a>C库函数和系统函数的关系（printf举例）</h1><p><img src="/images/printf.png"></p>
<p>库函数和系统函数的关系是: 调用和被调用的关系;库函数是对系统函数的进一步封装.</p>
<p>系统调用: 由操作系统实现并提供给外部应用程序的编程接口(Application Programming Interface, API), 是应用程序同系统之间数据交互的桥梁.</p>
<h1 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h1><p><img src="/images/virtual.png"></p>
<p>以32位系统为例，系统会为每一个进程分配0~4G的空间（虚拟地址空间）。<br>（1）进程的虚拟地址空间分为用户区和内核区, 其中内核区是受保护的, 用户是不能够对其进行读写操作的;<br>（2）内核区中很重要的一个就是进程管理, 进程管理中有一个区域就是PCB(本质是一个结构体);<br>（3）PCB中有文件描述符表, 文件描述符表中存放着打开的文件描述符, 涉及到文件的IO操作都会用到这个文件描述符.</p>
<h1 id="PCB和文件描述符"><a href="#PCB和文件描述符" class="headerlink" title="PCB和文件描述符"></a>PCB和文件描述符</h1><p><img src="/images/pcb.png"></p>
<p>备注:<br>pcb：结构体:task_stuct, 该结构体在:<br>&#x2F;usr&#x2F;src&#x2F;linux-headers-4.4.0-97&#x2F;include&#x2F;linux&#x2F;sched.h:1390<br>一个进程有一个文件描述符表：1024<br>前三个被占用, 分别是STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO<br>文件描述符作用：通过文件描述符找到inode, 通过inode找到磁盘数据块.</p>
<p>虚拟地址空间–&gt;内核区–&gt;进程管理–&gt;pcb–&gt;文件描述表–&gt;文件描述符–&gt;使用IO操作使用文件描述符</p>
<ul>
<li><p>lseek函数常用操作<br>文件指针移动到头部<br>lseek(fd, 0, SEEK_SET);<br>获取文件指针当前位置<br>int len &#x3D; lseek(fd, 0, SEEK_CUR);<br>获取文件长度<br>int len &#x3D; lseek(fd, 0, SEEK_END);<br>lseek实现文件拓展<br>off_t currpos;<br>&#x2F;&#x2F; 从文件尾部开始向后拓展1000个字节<br>currpos &#x3D; lseek(fd, 1000, SEEK_END);<br>&#x2F;&#x2F; 额外执行一次写操作，否则文件无法完成拓展<br>write(fd, “a”, 1);    &#x2F;&#x2F; 数据随便写</p>
</li>
<li><p>文件权限计算方法:<br>mode &amp; ~umask</p>
</li>
<li><p>思考: 阻塞和非阻塞是文件的属性还是read函数的属性?<br>（1）通过读普通文件测试得知: read函数在读完文件内容之后, 若再次read,则read函数会立刻返回, 表明read函数读普通文件是非阻塞的.<br>（2）设备文件:&#x2F;dev&#x2F;tty 和 标准输入STDIN_FILENO，通过读&#x2F;dev&#x2F;tty终端设备文件和标准输入, 表明read函数读设备文件是阻塞的.<br>（3）结论: 阻塞和非阻塞不是read函数的属性, 而是文件本身的属性.<br>socket pipe这两种文件都是阻塞的.</p>
</li>
</ul>
<h1 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h1><ul>
<li>使用st_mode成员判断文件类型:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//方法一</span><br><span class="line">   if((sb.st_mode &amp; S_IFMT) ==S_IFLNK)</span><br><span class="line">   &#123;   </span><br><span class="line">       printf(&quot;连接文件\n&quot;);</span><br><span class="line">   &#125;   </span><br><span class="line">   </span><br><span class="line">//方法二</span><br><span class="line">   if (S_ISREG(sb.st_mode)) </span><br><span class="line">   &#123;   </span><br><span class="line">       printf(&quot;普通文件\n&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>判断文件权限:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> if(sb.st_mode &amp; S_IROTH)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;---R----&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>lstat和stat函数:<br>（1）对于普通文件来说, lstat函数和stat函数一样<br>（2）对于软连接文件来说, lstat函数获取的是连接文件本身的属性,<br>（3）stat函数获取的是连接文件指向的文件的属性.</p>
</li>
<li><p>目录操作:<br>（1）打开目录 opendir<br>（2）循环读目录: readdir<br>（3）关闭目录: closedir</p>
</li>
<li><p>dup和dup2函数:复制文件描述符—-详情看图</p>
</li>
</ul>
<p><img src="/images/dup.png"></p>
<ul>
<li>fcntl函数:<br>(1)复制文件描述符: int fd &#x3D; fcntl(oldfd, F_DUPFD, 0);<br>(2)获得和设置文件的flag属性:<br>int flag &#x3D; fcntl(fd, F_GETFL, 0);<br>flag &#x3D;flag|O_APPEND;<br>fcntl(fd, F_SETFL, flag);</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/23/makefill-gdb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/23/makefill-gdb/" class="post-title-link" itemprop="url">makefill gdb</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-23 18:09:16" itemprop="dateCreated datePublished" datetime="2022-04-23T18:09:16+08:00">2022-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-31 18:54:08" itemprop="dateModified" datetime="2022-07-31T18:54:08+08:00">2022-07-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>makefile:<br>makefile文件是用来管理项目工程文件, 通过执行make命令, make就会解析并执行makefile文件.<br>makefile命名: makefile或者Makefile</p>
</li>
<li><p>makefile的编写:<br>规则如下:<br>目标: 依赖<br>(tab)命令</p>
</li>
<li><p>第一个版本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main: main.c fun1.c fun2.c sum.c</span><br><span class="line">	gcc -o main main.c fun1.c fun2.c sum.c</span><br></pre></td></tr></table></figure>
<p>缺点: 效率低, 修改一个文件, 所有的文件会全部重新编译.</p>
</li>
<li><p>第二个版本：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 main:main.o fun1.o fun2.o</span><br><span class="line">2     gcc -o main main.o fun1.o fun2.o</span><br><span class="line">3 main.o:main.c</span><br><span class="line">4     gcc -c main.c -I ./</span><br><span class="line">5 fun1.o:fun1.c</span><br><span class="line">6     gcc -c fun1.c</span><br><span class="line">7 fun2.o:fun2.c</span><br><span class="line">8     gcc -c fun2.c</span><br></pre></td></tr></table></figure>

<p>检查规则:<br>要想生成目标文件, 先要检查依赖条件是否都存在.<br>若都存在, 则比较目标时间和依赖的时间, 如果依赖的时候比目标的时间新,则重新生成目标; 否则不重新生成.<br>若不存在, 则往下找有没有生成依赖的规则, 有则生成, 如果没有则报错.<br>第二版本的缺点: 冗余, 若.c文件数量很多, 编写起来比较麻烦.</p>
<ul>
<li>第三个版本：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1 target=main</span><br><span class="line"> 2 objects=main.o fun1.o fun2.o</span><br><span class="line"> 3 CC=gcc</span><br><span class="line"> 4 CPPFLAGS=-I./</span><br><span class="line"> 5</span><br><span class="line"> 6 $(target):$(objects)</span><br><span class="line"> 7     $(CC) -o $@ $^</span><br><span class="line"> 8 %.o:%.c</span><br><span class="line"> 9     $(CC) -c $&lt; $(CPPFLAGS)</span><br><span class="line">10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>变量:<br>自定义变量: var &#x3D; hello, $(var)<br>自带变量: CC CPPFLAGS CFLAGS LDFLAGS<br>自动变量: $@ $&lt; $^<br>模式规则: %.o:%.c——&gt; 前后的%必须是相同 </p>
<ul>
<li>第四个版本：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1 target=main</span><br><span class="line"> 2 src=$(wildcard *.c)</span><br><span class="line"> 3 objects=$(patsubst %.c,%.o,$(src))</span><br><span class="line"> 4 CC=gcc</span><br><span class="line"> 5 CPPFLAGS=-I./</span><br><span class="line"> 6</span><br><span class="line"> 7 $(target):$(objects)</span><br><span class="line"> 8     $(CC) -o $@ $^</span><br><span class="line"> 9 %.o:%.c</span><br><span class="line">10     $(CC) -c $&lt; $(CPPFLAGS)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>makefile函数：<br>1.wildcard – 查找指定目录下的指定类型的文件<br>src&#x3D;$(wildcard *.c)  &#x2F;&#x2F;找到当前目录下所有后缀为.c的文件,赋值给src<br>2.patsubst – 匹配替换<br>obj&#x3D;$(patsubst %.c,%.o, $(src)) &#x2F;&#x2F;把src变量里所有后缀为.c的文件替换成.o<br>如: 当前目录下有a.c b.c c.c<br>src&#x3D;$(wildcard *.c) —–&gt; src&#x3D;a.c b.c c.c<br>obj&#x3D;$(patsubst %.c,%.o, $(src)) —–&gt; obj&#x3D;a.o b.o c.o</p>
<ul>
<li>第五个版本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 1 target=main</span><br><span class="line"> 2 src=$(wildcard *.c)</span><br><span class="line"> 3 objects=$(patsubst %.c,%.o,$(src))</span><br><span class="line"> 4 CC=gcc</span><br><span class="line"> 5 CPPFLAGS=-I./</span><br><span class="line"> 6</span><br><span class="line"> 7 $(target):$(objects)  #第一个目标即为终极目标，直接make就会运行！！！</span><br><span class="line"> 8     $(CC) -o $@ $^</span><br><span class="line"> 9 %.o:%.c</span><br><span class="line">10     $(CC) -c $&lt; $(CPPFLAGS)</span><br><span class="line">11</span><br><span class="line">12 .PHONY:clean  #声明为伪目标。   非第一个目标，make clean才会运行嗷</span><br><span class="line">13 clean:</span><br><span class="line">14     -rm -f $(objects) $(target)   #rm前加-,可以保证clean下的前一个命令如果无法执行，不会影响在其后面加-的命令的执行！   rm -f: 强制执行, 比如若要删除的文件不存在使用-f不会报错。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>增加清理功能.<br>终极目标: makefile文件中第一次出现的目标叫做终极目标。<br>伪目标：声明目标为伪目标之后, makefile将不会检查该目标是否存在或者该目标是否需要更新。<br>.PHONY:clean<br>clean:<br>rm -f ….        </p>
<ul>
<li><p>使用-f可以指定makefile文件（因为执行make默认找的是makefile文件，通过-f参数可以指定其他名称的makefile文件）, 如: make -f new_makefile</p>
</li>
<li><p>gdb调试 :</p>
</li>
</ul>
<p>gdb是在程序运行的结果与预期不符合的时候, 可以使用gdb进行调试,<br>特别注意的是: 使用gdb调试需要在编译的时候加-g参数!!!!!!!</p>
<p>启动gdb:<br>gdb program<br>set args hello world<br>show args<br>执行程序:<br>run  #执行到断点位置，无断点，则执行完<br>start #第一条语句停下来</p>
<p>list操作:<br>list<br>list -<br>list func<br>list linenum<br>list file:func<br>list file:linenum<br>set listsize n<br>show listsize</p>
<p>断点操作:<br>b linenum<br>b func<br>b file:linenum<br>b file:func</p>
<p>info break</p>
<p>disable m n | m-n<br>enable  m n | m-n<br>delete m n | m-n </p>
<p>条件断点<br>一般来说, 为断点设置一个条件, 我们使用if关键词, 后面跟其断点条件。设置一个条件断点：<br>b test.c:8 if intValue &#x3D;&#x3D; 5</p>
<p>调试命令:<br>run （全部执行，直至第一个断点处）<br>start （执行至第一条语句）<br>next  （单步执行，不进入函数体）<br>step  （单步执行，进入函数体）<br>finish  （跳出函数体）<br>until  （执行完循环体）<br>continue  （执行至下一个断点处）</p>
<p>print var  （打印变量值）</p>
<p>自动显示:<br>display var  （显示变量）</p>
<p>info display  （列出所有需要显示的变量信息）</p>
<p>disable display m n | m-n   （使变量显示失效）<br>enable display m n | m-n     （使变量显示生效）</p>
<p>delete display m n | m-n   （删除需要显示的变量）<br>undisplay m n | m-n    （删除需要显示的变量）</p>
<p>多进程调试？？？？</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/20/vim_gcc%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C%E5%92%8C%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/20/vim_gcc%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C%E5%92%8C%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">vim gcc库制作和使用</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-20 17:05:29" itemprop="dateCreated datePublished" datetime="2022-04-20T17:05:29+08:00">2022-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-29 21:35:08" itemprop="dateModified" datetime="2022-04-29T21:35:08+08:00">2022-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#gcc的工作流程<br><img src="/images/gcc.png"><br><img src="/images/gcc2.png"><br>1.预处理：cpp预处理器，去掉注释，展开头文件，宏替换<br>gcc -E test.c -o test.i<br>2.编译：gcc,将源代码文件编译成汇编代码<br>gcc -S test.i -o test.s<br>3.汇编：as，将汇编语言代码编译成二进制文件（目标代码）<br>gcc -c test.s -o test.o<br>4.链接：ld，链接test.c代码中调用的库函数<br>gcc test.o -o test.exe<br>#gcc的常用参数<br>-c  只编译, 生成.o文件, 通常称为目标文件<br>-I   指定头文件所在的路径<br>-L   指定库文件所在的路径<br>-l    指定库的名字<br>-o   指定生成的目标文件的名字<br>-g   包含调试信息, 使用gdb调试需要添加-g参数<br>#库</p>
<ul>
<li>库是二进制文件, 是源代码文件的另一种表现形式, 是加了密的源代码;<br>是一些功能相近或者是相似的函数的集合体</li>
</ul>
<h2 id="库可分静态库-static-library-和共享库-shared-library"><a href="#库可分静态库-static-library-和共享库-shared-library" class="headerlink" title="库可分静态库(static library)和共享库(shared library)"></a>库可分静态库(static library)和共享库(shared library)</h2><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><ul>
<li>静态库的制作：</li>
</ul>
<p>1.将.c文件编译成.o文件<br>gcc -c func1.c func2.c<br>2.使用ar命令将.o文件打包成.a文件<br>ar rcs libtest1.a func1.o func2.o</p>
<ul>
<li>静态库的使用（注意库名字是test1,去掉lib和.a）<br>gcc mian.c -I .&#x2F; -L .&#x2F; -l test1 -o main1<br>运行：.&#x2F;main1</li>
</ul>
<h2 id="静态库的优缺点"><a href="#静态库的优缺点" class="headerlink" title="静态库的优缺点"></a>静态库的优缺点</h2><ul>
<li>优点：</li>
</ul>
<p>函数库最终被打包到应用程序中，实现是函数本地化，寻址方便、速度快。<br>（库函数调用效率&#x3D;&#x3D;自定义函数使用效率）<br>程序在运行时与函数库再无瓜葛，移植方便。</p>
<ul>
<li>缺点：</li>
</ul>
<p>消耗系统资源较大, 每个进程使用静态库都要复制一份, 无端浪费内存。</p>
<p>静态库会给程序的更新、部署和发布带来麻烦。如果静态库libxxx.a更新了，所有使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载）。</p>
<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><ul>
<li>动态库的制作</li>
</ul>
<p>1.生成目标文件.o, 此时要加编译选项：-fPIC（fpic）<br>gcc -fpic -c fun1.c fun2.c<br>参数：-fpic创建与地址无关的编译程序(pic, position independent code), 目的就是为了能够在多个应用程序间共享.<br>2.生成共享库, 此时要加链接器选项: -shared（指定生成动态链接库）<br>gcc -shared fun1.o fun2.o -o libtest2.so</p>
<ul>
<li>动态库的使用</li>
</ul>
<p>gcc main.c -I.&#x2F; -L.&#x2F; -ltest2 -o main2<br>运行：.&#x2F;main2报错了！<br>动态库文件在编译的时候, 连接器需要使用参数-L找到库文件所在的路径;<br>在执行的时候, 是加载器ldd根据动态库的路径进行加载的, 与编译的时候用的-L<br>指定的路径无关.<br>最常用的解决办法:将LD_LIBRARY_PATH环境变量加到用户级别的配置文件<del>&#x2F;.bashrc中,<br>然后生效(. ~&#x2F;.bashrc    source ~&#x2F;.bashrc   退出终端然后再登录)<br>（1）dll放在用户家目录的新建的lib文件夹中，&#x2F;home&#x2F;qcc&#x2F;lib&#x2F;,配置如下<br>export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:</del>&#x2F;lib<br>（2）dll放在当前目录下或者当前目录的lib子目录下均可以的配置如下：<br>export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:.&#x2F;lib</p>
<ul>
<li><p>共享库的特点<br>动态库把对一些库函数的链接载入推迟到程序运行的时期。<br>可以实现进程之间的资源共享。（因此动态库也称为共享库）<br>将一些程序升级变得简单。<br>甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）</p>
</li>
<li><p>比较静态库和动态库的优缺点<br> 静态库的优点:<br>   1 执行速度快, 是因为静态库已经编译到可执行文件内部了<br>   2 移植方便, 不依赖域其他的库文件<br> 缺点:<br>   1 耗费内存, 是由于每一个静态库的可执行程序都会加载一次<br>   2 部署更新麻烦, 因为静态库修改以后所有的调用到这个静态库的可执行文<br>件都需要重新编译</p>
</li>
</ul>
<p> 动态库的优点:<br>     1 节省内存<br>     2 部署升级更新方便, 只需替换动态库即可, 然后再重启服务.<br> 缺点:<br>     1 加载速度比静态库慢<br>     2 移植性差, 需要把所有用到的动态库都移植.</p>
<p>由于由静态库生成的可执行文件是把静态库加载到了其内部, 所以静态库生成的可执行文件一般会比动态库大.</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/19/%E9%BB%91%E9%A9%AC_linux%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/19/%E9%BB%91%E9%A9%AC_linux%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Linux基础</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-19 15:53:32" itemprop="dateCreated datePublished" datetime="2022-04-19T15:53:32+08:00">2022-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-20 16:38:54" itemprop="dateModified" datetime="2022-04-20T16:38:54+08:00">2022-04-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#linux基础–基础命令</p>
<ol>
<li><p>shell相关：shell就是命令解释器，shell将用户输入的命令解释成内核能够识别的指令。<br> 查看当前系统使用的shell：echo $SHELL<br> 当前系统支持的shell:cat &#x2F;etc&#x2F;shells</p>
</li>
<li><p>history会显示历史输入的所有命令。</p>
</li>
<li><p>linux下一切皆文件，有：字符设备文件（键盘&#x2F;鼠标）、块设备文件（硬盘）。</p>
</li>
<li><p>linux的目录结构：是一个倒立的树状结构<br>  &#x2F;bin: ls cp mv<br>  &#x2F;sbin: ifconfig halt shutdown<br>  &#x2F;lib: 库目录<br>  &#x2F;root: root用户的家目录<br>  &#x2F;dev: 字符设备和块设备.  在linux下, 一切皆是文件.<br>  &#x2F;home: 用户的家目录<br>  &#x2F;usr: 相当于windows的program files<br>  &#x2F;etc: 系统级别的配置文件<br>  &#x2F;mnt:<br>  &#x2F;media<br>  &#x2F;tmp<br>  &#x2F;opt</p>
</li>
<li><p>相对路径和绝对路径<br> 相对路径: 从当前目录开始表示的目录.<br> 绝对路径: 从根（&#x2F;）目录开始表示的目录.</p>
</li>
<li><p>tree命令，以树状形式查看指定目录内容，使用该命令需要安装软件tree。sudo apt-get install tree。<br> 用法： tree 目录</p>
</li>
<li><p>ls命令<br> ls -la  列出当前目录下所有文件的相信信息, 包括隐藏文件.<br> ls -ltr 列出当前目录下的文件, 按照时间逆向排序.(t:time,r:reverse)</p>
</li>
</ol>
<p>ls -l命令输出详解如下：</p>
<p><img src="/images/linux_ls.png"><br>说明：（1）计数参数：对于目录来说, 链接计数等于该目录下所有的目录总数(含. 和 ..), 但是不包含该目录的子目录下的目录文件数量, 执行ls -la命令可以进行查看。对于文件来说, 指的是该文件所有的硬链接文件数量。<br>（2）大小参数（单位：字节）：如果是目录: 只表示目录大小, 不包含目录中的内容, 目录大小为4k。如果是文件：表示文件大小.</p>
<p>8.cd命令：临近两个目录直接切换：cd -<br>如：开始在: &#x2F;home&#x2F;itcast&#x2F;test&#x2F;course&#x2F;day1&#x2F;test目录下, 执行了cd命令切换到家目录下, 然后在执行cd -又回到了&#x2F;home&#x2F;itcast&#x2F;test&#x2F;course&#x2F;day1&#x2F;test下.<br>~代表用户的家目录，如：cd等价于cd ~等价于cd &#x2F;home&#x2F;qcc</p>
<p>9.which命令：查看命令所在的目录。 如which ls   which cp。</p>
<p>10.pwd：显示当前目录。</p>
<p>11.touch命令<br>如果文件不存在, 创建新文件, 如果文件存在, 更新文件的最后修改时间（内容不变）。<br>命令使用方式：touch 文件名</p>
<p>12.mkdir命令<br>创建新目录, make directory<br>创建方式：mkdir目录名<br>如果创建多级目录需要添加参数 -p （parent）<br>例 ：在当前目录下创建目录:  mkdir mydir<br>在宿主目录下创建多级目录:  mkdir -p ~&#x2F;test&#x2F;hello&#x2F;world&#x2F;aa</p>
<p>13.rm命令<br>删除文件： rm 文件名<br>删除目录： rm  -r 目录名<br>参数：<br>-r：递归删除目录，删除目录必须添加此参数<br>-i：提示用户是否删除文件或目录<br>-f：强制删除<br>注意事项：<br>使用rm命令删除的文件或目录不会放入回收站中，数据不易恢复。</p>
<p>14.cp命令<br>cp命令: cp 源文件  目标文件<br>cp file1 file2 (不存在)<br>cp file1 file2 (存在)<br>cp file dir(必须存在)<br>cp -r dir1 dir2(不存在)<br>cp -r dir1 dir2(存在)<br>cp -a file1 file2（将属性也复制，创建时间也会被复制）</p>
<p>15.mv命令<br>mv命令: mv 源文件  目标文件<br>改名:<br>mv file1 file2(不存在)<br>mv file1 file2(存在)<br>mv dir1 dir2(不存在)</p>
<p>移动:<br>mv file dir (必须存在)<br>mv dir1 dir2(存在) </p>
<p>16.查看文件内容<br>cat more less head tail<br>tail -f test.log: 实时显示文件内容</p>
<h2 id="一个比较重要的应用：实时的显示日志-tail-f-test-log"><a href="#一个比较重要的应用：实时的显示日志-tail-f-test-log" class="headerlink" title="一个比较重要的应用：实时的显示日志 : tail -f test.log"></a>一个比较重要的应用：实时的显示日志 : tail -f test.log</h2><h2 id="例子：一个终端tail-f-test-log-另一个终端-echo-“hello-world”-gt-gt-test-log（-gt-是覆盖，-gt-gt-是追加）"><a href="#例子：一个终端tail-f-test-log-另一个终端-echo-“hello-world”-gt-gt-test-log（-gt-是覆盖，-gt-gt-是追加）" class="headerlink" title="例子：一个终端tail -f test.log , 另一个终端: echo “hello world” &gt;&gt;test.log（&gt;是覆盖，&gt;&gt;是追加）"></a>例子：一个终端tail -f test.log , 另一个终端: echo “hello world” &gt;&gt;test.log（&gt;是覆盖，&gt;&gt;是追加）</h2><p>17.软链接（文件和目录都可以创建软链接）</p>
<ul>
<li><p>相当于windows下的快捷方式。</p>
</li>
<li><p>ln -s 源文件 链接文件</p>
</li>
<li><p>注意点: 创建软连接，源文件一定要使用绝对路径！ 否则, 当软连接文件<br> 移动位置之后, 就会找不到指向的文件了.</p>
</li>
<li><p>软连接文件的大小是: 路径+文件名的总字节数，软链接存放的实际上存放的是源文件的路径。</p>
</li>
<li><p>删除源文件后，软链接就无法访问数据了。</p>
</li>
</ul>
<p>18.硬链接<br><img src="/images/hard_link.png"></p>
<ul>
<li><p>ln soucefile  desfile</p>
</li>
<li><p>硬链接不能建立在目录上</p>
</li>
<li><p>硬连接不能跨文件系统<br>硬链接文件和源文件的inode是相同的，文件系统的inode要求唯一，跨文件系统可能会使inode不同, 所以硬链接不能跨文件系统</p>
</li>
<li><p>创建一个硬链接文件, 硬链接计数+1, 删除一个则-1;    </p>
</li>
<li><p>ls -li: 可以查看文件的inode</p>
</li>
<li><p>作用:<br>1 可以起到同步文件的作用<br>2 可以起到保护文件的作用（当计数器变为0，才会删除）</p>
</li>
</ul>
<p>19.chmod修改文件权限</p>
<ul>
<li><p>文字设定法: chmod ug+wx file.log  (u&#x2F;g&#x2F;o&#x2F;a  r&#x2F;w&#x2F;x)  (+&#x2F;-&#x2F;&#x3D;)</p>
</li>
<li><p>数字设定法: chmod 777  file.log</p>
</li>
</ul>
<p>20.chown修改文件所有者和所属组（：&#x2F;.都可以）<br>sudo chown qcc:qcc aa.log<br>sudo chown mytest.mytest aa.log<br>sudo chown :mytest aa.log<br>sudo chown .mytest aa.log</p>
<p>21.chgrp修改文件所属组<br>sudo chgrp mytest aa.log<br>22.find命令<br>-name:<br>-type:<br>-size<br>-maxdepth&#x2F;mindepth<br>-ctime&#x2F;atime&#x2F;mtime<br>find path -name “<em>.c” -exec shell命令 {} ;<br>find path -name “</em>.c” | xargs shell命令<br>23.grep<br>-n:显示行<br>-i:忽略大小写<br>-v:不显示包含搜素字符串的行，显示其他行<br>-r:    若是目录，可以递归搜索<br>find和grep结合使用:<br>find .&#x2F; -name “*.sh” | xargs grep -n “while”<br>24.软件安装和卸载<br>在线安装<br>软件安装：sudo apt-get install 软件名<br>软件卸载：sudo apt-get remove 软件名<br>更新软件列表：sudo apt-get update<br>清理安装包：sudo apt-get clean<br>清理的是缓存路径：&#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives<br>软件包安装<br>在Ubuntu系统下必须有deb格式的安装包<br>软件安装<br>sudo dpkg -i xxx.deb<br>软件卸载<br>sudo dpkg -r 软件名<br>25.压缩和解压缩</p>
<ul>
<li><p>gzip和bzip2（不常用）<br>不能压缩目录，只能一个一个文件进行压缩，压缩之后会使原文件消失<br>gzip *    压缩当前目录下所有的文件, 但是目录不能压缩<br>gunzip *  解压当前目录下所有的.gz文件<br>bzip2 *   压缩当前目录下所有的文件, 但是目录不能压缩<br>bunzip2 * 解压当前目录下所有的. bz2文件</p>
</li>
<li><p>tar(常用)<br>tar -cvf my.tar file dir(打包成tar包，并未压缩！！！)<br>tar -xvf my.tar -C mydir（解开tar包）(-C指定解压后的目录)(c&#x2F;x互斥出现)</p>
</li>
</ul>
<p>(gzip形式压缩与解压)<br>tar -zcvf my.tar.gz file dir<br>tar -zxvf my.tar.gz -C mydir<br>(bzip2形式压缩和解压)<br>tar -jcvf my.tar.bz2 file dir<br>tar -jxvf my.tar.bz2 -C mydir</p>
<p>（zip形式压缩与解压）<br>zip:<br>      zip -r xxx file dir （-r是有目录的情况）<br>unzip:<br>      unzip xxx.zip -d &#x2F;home&#x2F;itcast&#x2F;test&#x2F;day1</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/16/http%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/16/http%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">http服务器项目开发</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-16 20:01:32" itemprop="dateCreated datePublished" datetime="2022-04-16T20:01:32+08:00">2022-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-17 18:28:26" itemprop="dateModified" datetime="2022-04-17T18:28:26+08:00">2022-04-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/13/samba%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/13/samba%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">samba服务器</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-13 16:12:24 / 修改时间：16:29:05" itemprop="dateCreated datePublished" datetime="2022-04-13T16:12:24+08:00">2022-04-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="samba服务器简介"><a href="#samba服务器简介" class="headerlink" title="samba服务器简介"></a>samba服务器简介</h2><ul>
<li><p>实现windows和unix系列系统之间能够相互沟通，就产生了samba服务。</p>
</li>
<li><p>samba是架构在NetBIOS（Network Basic Input&#x2F;Output System,网上基本输入输出系统）这个通信协议上面所开发出来的。NetBIOS是由IBM发展出来，目的是要让局域网络内少数计算机进行网络连接的一个通信协议，因此NetBIOS是无法跨越路由的，而现在Samba不仅能与局域网主机分享资源，还能与全世界的电脑分享资源，就是由NetBIOS over TCP&#x2F;IP技术解决。由于NetBIOS在局域网内实在是很好用，所以微软的网络架构就使用了这个协议。而samba最早发展的时候，其实是想要让linux系统可以加入windows的系统当中来共享使用彼此的文件数据，所以samba就架构在NetBIOS发展出来了</p>
</li>
</ul>
<h2 id="Ubuntu安装Samba服务器"><a href="#Ubuntu安装Samba服务器" class="headerlink" title="Ubuntu安装Samba服务器"></a>Ubuntu安装Samba服务器</h2><ol>
<li>确认安装：dpkg l | grep samba</li>
<li>安装：sudo apt-get install samba samba-common</li>
<li>卸载：sudo apt-get autoremove samba<h2 id="Samba服务器配置"><a href="#Samba服务器配置" class="headerlink" title="Samba服务器配置"></a>Samba服务器配置</h2></li>
</ol>
<ul>
<li>sudo vim &#x2F;etc&#x2F;samba&#x2F;smb.conf</li>
<li>在文件的最后添加</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[share]</span><br><span class="line">comment=This is samba dir</span><br><span class="line">path=/home/qcc/</span><br><span class="line">writable=yes</span><br><span class="line">browseable=yes</span><br></pre></td></tr></table></figure>
<ul>
<li>增加samba用户</li>
<li>sudo smbpasswd -a qcc (密码设置需要与linux的密码一致)<h2 id="启动和关闭"><a href="#启动和关闭" class="headerlink" title="启动和关闭"></a>启动和关闭</h2></li>
<li>注意添加新用户后，需要重启samba服务器</li>
<li>启动：sudo service smbd start</li>
<li>关闭 ：sudo service smbd stop<br>##直接在windows在编码</li>
<li>在windows色目录上方，写入：\局域网（linux的）ip地址,然后就能在windows下编辑linux下的文件了！</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/11/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8Esocket%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/11/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8Esocket%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">网络通信与socket编程</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-11 20:01:12" itemprop="dateCreated datePublished" datetime="2022-04-11T20:01:12+08:00">2022-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-16 19:47:48" itemprop="dateModified" datetime="2022-05-16T19:47:48+08:00">2022-05-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-socket通信的3要素"><a href="#1-socket通信的3要素" class="headerlink" title="1.socket通信的3要素"></a>1.socket通信的3要素</h1><ol>
<li>通信的目的地址</li>
<li>使用的端口号（例如：http默认的是80端口，smtp(邮件传输端口):25）</li>
<li>使用的传输层协议（如：TCP&#x2F;UDP）</li>
</ol>
<h1 id="2-socket概念"><a href="#2-socket概念" class="headerlink" title="2.socket概念"></a>2.socket概念</h1><ul>
<li><p>（int类型） 在Linux环境下，用于表示进程间网络通信的特殊文件类型，本质为内核借助缓冲区形成的伪文件。</p>
</li>
<li><p>套接字的读写和文件操作一致，区别是文件主要应用于本地持久化数据的读写（磁盘），而套接字应用于网络进程间数据的传递。</p>
</li>
<li><p>在TCP&#x2F;IP协议中，IP地址+TCP或UDP端口号来唯一标识网络通信中的一个进程。IP地址+端口号就对应一个socket，欲建立连接的两个进程各有一个socket，那么这两个socket组成的socket pair就唯一的标识一个连接，因此，可以用socket来描述网络连接中的一对一关系。<br><img src="/images/c_s.png"></p>
</li>
<li><p>在网络通信中，套接字一定是成对出现的，一端的发送缓冲区对应另一端的接收缓冲区，使用同一个文件描述符发送缓冲区和接收缓冲区。</p>
</li>
</ul>
<h1 id="3-socket通信创建流程"><a href="#3-socket通信创建流程" class="headerlink" title="3.socket通信创建流程"></a>3.socket通信创建流程</h1><p><img src="/images/socket.png"></p>
<h1 id="4-socket编程基础"><a href="#4-socket编程基础" class="headerlink" title="4.socket编程基础"></a>4.socket编程基础</h1><ul>
<li>大端字节序：低地址存放高字节！</li>
<li>小端字节序：低地址存放低字节！</li>
<li>网络数据流发出的顺序是，先发送的数据是低地址存放的数据，后发送的数据是高地址存放的数据。</li>
<li>TCP&#x2F;IP协议规定：网络数据流应采用大端字节序。</li>
<li>由于网络数据流采取的是大端字节序，所以，如果主机是小端字节序，那么需要转化为大端字节序，再进行传输；如果主机是大端字节序，则不做转化。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//本机字节序测试</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//借助共用体，公用同一块内存空间</span><br><span class="line">union&#123;</span><br><span class="line">	short s;</span><br><span class="line">	char c[sizeof(short)];</span><br><span class="line">&#125; un2;</span><br><span class="line"></span><br><span class="line">union&#123;</span><br><span class="line">	int s;</span><br><span class="line">	char c[sizeof(int)];</span><br><span class="line">&#125; un4;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	printf(&quot;sizeof(short)=[%d],sizeof(int)=[%d]\n&quot;,sizeof(short),sizeof(int));</span><br><span class="line">	</span><br><span class="line">	//测试short类型，运行结果可以看出，低地址存放了低字节，所以是小端字节序！！！</span><br><span class="line">	un2.s=0x0102;</span><br><span class="line">	printf(&quot;%d,%d,%d\n&quot;,un2.c[0],un2.c[1],un2.s);</span><br><span class="line">	</span><br><span class="line">	//测试int类型</span><br><span class="line">	un4.s=0x01020304;</span><br><span class="line">	printf(&quot;%d,%d,%d,%d,%d\n&quot;,un4.c[0],un4.c[1],un4.c[2],un4.c[3],un4.s);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果（低地址存放了低字节，所以是小端字节序）：</li>
</ul>
<p><img src="/images/socket.png"></p>
<ul>
<li>对应的API函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">uint32_t htonl(uint32_t hostlong);</span><br><span class="line">uint16_t htons(uint16_t hostshort);</span><br><span class="line">uint32_t ntohl(uint32_t netlong);</span><br><span class="line">uint16_t ntohs(uint16_t netshort);</span><br><span class="line">h表示host，n表示network，l表示32位长整数，s表示16位短整数。</span><br><span class="line">32位的是IP地址，16位的是端口号</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-1-sockaddr数据结构-存在历史遗留问题"><a href="#4-1-sockaddr数据结构-存在历史遗留问题" class="headerlink" title="4.1 sockaddr数据结构(存在历史遗留问题)"></a>4.1 sockaddr数据结构(存在历史遗留问题)</h2><ul>
<li>很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是其他的，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</li>
</ul>
<p><img src="/images/sockaddr.png"></p>
<ul>
<li>如上图，sockaddr_in实际上是将sockaddr进行了细化，16位的地址类型没变，将剩下的14个字节的数据分为2个字节的端口号，4个字节的IP地址（IPV4），8个字节的填充位。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr &#123;</span><br><span class="line">	sa_family_t sa_family; 		/* address family, AF_xxx */ 协议家族，AF_INET代表IPV4</span><br><span class="line">	char sa_data[14];			/* 14 bytes of protocol address */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> struct sockaddr_in &#123;</span><br><span class="line">     sa_family_t    sin_family; /* address family: AF_INET */</span><br><span class="line">     in_port_t      sin_port;   /* port in network byte order */ 端口号</span><br><span class="line">     struct in_addr sin_addr;   /* internet address */  IP地址</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> /* Internet address. */</span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    uint32_t       s_addr;     /* address in network byte order */注意IP地址是32位无符号整型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>IPv4的地址格式定义在netinet&#x2F;in.h中，IPv4地址用sockaddr_in结构体表示，包括16位端口号和32位IP地址，但是sock API的实现早于ANSI C标准化，那时还没有void *类型，因此这些像bind 、accept函数的参数都用struct sockaddr *类型表示，在传递参数之前要强制类型转换一下，例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">bind(listen_fd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));		/* initialize servaddr */</span><br></pre></td></tr></table></figure>

<h2 id="4-2-IP地址转化函数"><a href="#4-2-IP地址转化函数" class="headerlink" title="4.2 IP地址转化函数"></a>4.2 IP地址转化函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int inet_pton(int af, const char *src, void *dst);</span><br><span class="line">const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</span><br><span class="line">af 取值可选为 AF_INET 和 AF_INET6 ，即和 ipv4 和ipv6对应</span><br><span class="line">支持IPv4和IPv6</span><br></pre></td></tr></table></figure>
<p>其中inet_pton和inet_ntop不仅可以转换IPv4的in_addr，还可以转换IPv6的in6_addr。<br>因此函数接口是void *addrptr</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line"></span><br><span class="line">    char ip[]=&quot;2.3.4.5&quot;;</span><br><span class="line">    char server_ip[64];</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in server_addr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    inet_pton(AF_INET, ip, &amp;server_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    printf(&quot;s_addr : %x\n&quot;, server_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    printf(&quot;s_addr from net to host: %x\n&quot;, ntohl(server_addr.sin_addr.s_addr));</span><br><span class="line"></span><br><span class="line">    inet_ntop(AF_INET, &amp;server_addr.sin_addr.s_addr, server_ip, 64);</span><br><span class="line"></span><br><span class="line">    printf(&quot;server ip : %s\n&quot;, server_ip);</span><br><span class="line"></span><br><span class="line">    printf(&quot;INADDR_ANY: %d\n&quot;, INADDR_ANY);</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    inet_ntop(AF_INET, &amp;server_addr.sin_addr.s_addr, server_ip, 64);</span><br><span class="line">    printf(&quot;INADDR_ANY ip : %s\n&quot;, server_ip);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#5.socket编程函数</p>
<p>-** 5.1 socket函数**</p>
<ul>
<li>socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read&#x2F;write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可.</li>
<li>函数：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>

<p>-** 5.2 bind函数**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">sockfd：</span><br><span class="line">	socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">	构造出IP地址加端口号</span><br><span class="line">addrlen:</span><br><span class="line">	sizeof(addr)长度</span><br><span class="line">返回值：</span><br><span class="line">	成功返回0，失败返回-1, 设置errno</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。</li>
<li>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(6666);</span><br></pre></td></tr></table></figure>

<ul>
<li>首先将整个结构体清零，然后设置地址类型为AF_INET，网络地址为INADDR_ANY，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为6666</li>
</ul>
<p>-** 5.3 listen函数**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">sockfd:</span><br><span class="line">	socket文件描述符</span><br><span class="line">backlog:</span><br><span class="line">	在Linux 系统中，它是指排队等待建立3次握手队列长度</span><br></pre></td></tr></table></figure>


<ul>
<li><p>查看系统默认backlog<br>cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog</p>
</li>
<li><p>改变 系统限制的backlog 大小<br>vim &#x2F;etc&#x2F;sysctl.conf</p>
</li>
<li><p>最后添加<br>net.core.somaxconn &#x3D; 1024<br>net.ipv4.tcp_max_syn_backlog &#x3D; 1024</p>
</li>
<li><p>保存，然后执行<br>sysctl -p</p>
</li>
<li><p>注意：backlog需要手动去修改系统的内核参数，不然只调用listen是无法修改的！！！</p>
</li>
<li><p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接等待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</p>
</li>
</ul>
<p>-** 5.4 accept函数**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; 		/* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">sockdf:</span><br><span class="line">	socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">	传出参数，返回链接客户端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">	传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小</span><br><span class="line">返回值：</span><br><span class="line">	成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>三次握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。</li>
</ul>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line">	cliaddr_len = sizeof(cliaddr);</span><br><span class="line">	connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">	n = read(connfd, buf, MAXLINE);</span><br><span class="line">	......</span><br><span class="line">	close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭listenfd，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1。</li>
</ul>
<p>-** 5.5 connect函数**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt; 					/* See NOTES */</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">sockdf:</span><br><span class="line">	socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">	传入参数，指定服务器端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">	传入参数,传入sizeof(addr)大小</span><br><span class="line">返回值：</span><br><span class="line">	成功返回0，失败返回-1，设置errno</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端需要调用connect()连接服务器，connect和bind的参数形式一致，区别在于bind的参数是自己的地址，而connect的参数是对方的地址。connect()成功返回0，出错返回-1。</li>
</ul>
<p>-** 5.6 出错函数处理**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char *strerror(int errnum);     /* See NOTES */</span><br><span class="line">errnum:</span><br><span class="line">	传入参数,错误编号的值，一般取 errno 的值   该方法可以配合日志打印函数，输出错误在日志中</span><br><span class="line">返回值：</span><br><span class="line">	错误原因</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">void perror(const char *s);    /* See NOTES */</span><br><span class="line">s:</span><br><span class="line">	传入参数,自定义的描述</span><br><span class="line">返回值：</span><br><span class="line">	无</span><br><span class="line">向标准出错stderr 输出出错原因,不能打印在日志中</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="qcc"
      src="/images/cat.png">
  <p class="site-author-name" itemprop="name">qcc</p>
  <div class="site-description" itemprop="description">努力变强</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/iwsuccess" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;iwsuccess" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2274259107@qq.com" title="E-Mail → mailto:2274259107@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      链接网站
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://leetcode-cn.com/u/mou-gai/" title="https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;mou-gai&#x2F;" rel="noopener" target="_blank">leetcode</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-03 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qcc</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共38.3k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
