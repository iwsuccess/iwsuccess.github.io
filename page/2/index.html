<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="努力变强">
<meta property="og:type" content="website">
<meta property="og:title" content="一懒众衫小">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="一懒众衫小">
<meta property="og:description" content="努力变强">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="qcc">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>一懒众衫小</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
     <a target="_blank" rel="noopener" href="https://iwsuccess.github.io" class="github-corner" aria-label="View source on GitHub">
	<svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
		<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
		<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
		<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
	</svg>
     </a>
	<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}
	</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">一懒众衫小</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Freedom On High</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B2/" class="post-title-link" itemprop="url">网络编程2</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-19 20:24:47" itemprop="dateCreated datePublished" datetime="2022-05-19T20:24:47+08:00">2022-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-23 12:16:15" itemprop="dateModified" datetime="2022-05-23T12:16:15+08:00">2022-05-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图:"></a>TCP状态转换图:</h2><p><img src="/images/TCP.png"></p>
<p>1 三次握手过程:<br>    客户端: SYN_SENT—connect()<br>    服务端:      LISTEN–listen()   SYN_RCVD<br>    当三次握手完成后, 都处于ESTABLISHED状态<br>2 数据传输过程中状态不发生变化, 都是ESTABLISHED状态<br>3 四次挥手过程:<br>    主动关闭方: FIN_WAIT_T  FIN_WAIT_2 TIME_WAIT<br>    被动关闭方: CLOSE_WAIT  LAST_ACK</p>
<p>思考题?<br>    1 SYN_SENT状态出现在哪一方? 客户端<br>    2 SYN_RCVD状态出现在哪一方? 服务端<br>    3 TIME_WAIT状态出现在哪一方?  主动关闭方<br>    4 在数据传输的时候没有状态变化.</p>
<h2 id="TIME-WAIT是如何出现的"><a href="#TIME-WAIT是如何出现的" class="headerlink" title="TIME_WAIT是如何出现的:"></a>TIME_WAIT是如何出现的:</h2><pre><code>启动服务端, 启动客户端, 连接建好, 而且也可以正常发送数据;
然后先关闭服务端, 服务端就会出现TIME_WAIT状态.（具体显示是端口已被占用！！！）
会等待2MSL。
</code></pre>
<h2 id="为什么需要2MSL时间"><a href="#为什么需要2MSL时间" class="headerlink" title="为什么需要2MSL时间:"></a>为什么需要2MSL时间:</h2><p>原因一：让四次挥手的过程更加可靠，确保最后一个发送给对方的ACK能到达。<br>若对方没有收到ACK应答, 对方会再次发送FIN请求关闭, 此时在2MS时间内被动关闭方仍然可以发送ACK给对方.<br>原因二：为了保证在2MSL时间内, 不能启动相同的SOCKET-PAIR，如果启动（未设置端口复用），就会报错，显示端口已经被占用。<br>TIME_WAIT一定是出现在主动关闭的一方, 也就是说2MSL是针对主动关闭一方来说的;由于TCP有可能存在丢包重传, 丢包重传若发给了已经断开连接之后相同的socket-pair(该连接是新建的, 与原来的socket-pair完全相同, 双方使用的是相同的IP和端口), 这样会对之后的连接造成困扰,严重可能引起程序异常.</p>
<h2 id="设置端口复用"><a href="#设置端口复用" class="headerlink" title="设置端口复用:"></a>设置端口复用:</h2><pre><code>int opt = 1;
setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(int));
</code></pre>
<h2 id="shutdown和close的区别"><a href="#shutdown和close的区别" class="headerlink" title="shutdown和close的区别:"></a>shutdown和close的区别:</h2><p>1 shutdown可以实现半关闭, close不行<br>2 shutdown关闭的时候, 不考虑文件描述符的引用计数, 是直接彻底关闭<br>  close考虑文件描述符的引用计数, 调用一次close只是将引用计数减1,<br>  只有减小到0的时候才会真正关闭.</p>
<h2 id="长连接和端连接的概念"><a href="#长连接和端连接的概念" class="headerlink" title="长连接和端连接的概念:"></a>长连接和端连接的概念:</h2><pre><code>长连接: 连接建立好之后,一直保持连接不关闭
短连接: 连接使用完之后就立刻关闭.
</code></pre>
<h2 id="什么是心跳包"><a href="#什么是心跳包" class="headerlink" title="什么是心跳包?"></a>什么是心跳包?</h2><pre><code>用于监测长连接是否正常的字符串.
</code></pre>
<h2 id="在什么情况下使用心跳包"><a href="#在什么情况下使用心跳包" class="headerlink" title="在什么情况下使用心跳包?"></a>在什么情况下使用心跳包?</h2><pre><code>主要用于监测长连接是否正常.
</code></pre>
<h2 id="如何使用心跳包"><a href="#如何使用心跳包" class="headerlink" title="如何使用心跳包?"></a>如何使用心跳包?</h2><pre><code>通信双方需要协商规则(协议), 如4个字节长度+数据部分
</code></pre>
<h2 id="高并发服务器模型–select"><a href="#高并发服务器模型–select" class="headerlink" title="高并发服务器模型–select"></a>高并发服务器模型–select</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">//服务器端程序</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;netinet/ip.h&gt; /* superset of previous */</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;	</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">#include&quot;wrap.h&quot; //自己实现的已经封装好的函数，含有错误处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	//创建socket</span><br><span class="line">	int lfd=Socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">	</span><br><span class="line">	//设置端口复用，记得在bind之前就设置好端口复用</span><br><span class="line">	int opt = 1;</span><br><span class="line">	setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(int));</span><br><span class="line">	</span><br><span class="line">	//绑定</span><br><span class="line">	struct sockaddr_in addr;</span><br><span class="line">	bzero(&amp;addr,sizeof(addr));</span><br><span class="line">	addr.sin_family=AF_INET;</span><br><span class="line">	addr.sin_port=htons(1026);</span><br><span class="line">	addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">	</span><br><span class="line">	Bind(lfd,(struct sockaddr*)&amp;addr,sizeof(addr));</span><br><span class="line">	</span><br><span class="line">	//监听</span><br><span class="line">	Listen(lfd,128);</span><br><span class="line">	</span><br><span class="line">	//定义fd_set类型变量</span><br><span class="line">	fd_set readfds;</span><br><span class="line">	fd_set tmpfds;</span><br><span class="line">	</span><br><span class="line">	//清空集合</span><br><span class="line">	FD_ZERO(&amp;readfds);</span><br><span class="line">	FD_ZERO(&amp;tmpfds);</span><br><span class="line">	</span><br><span class="line">	//将lfd加入到readfds中，调用select委托内核监控</span><br><span class="line">	FD_SET(lfd,&amp;readfds);</span><br><span class="line">	</span><br><span class="line">	int nready;</span><br><span class="line">	int maxfd=lfd;</span><br><span class="line">	int cfd;</span><br><span class="line">	int i;</span><br><span class="line">	int n;</span><br><span class="line">	char buf[1024];</span><br><span class="line">	</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		</span><br><span class="line">		//由于select的第二个参数是传入传出参数，所以需要再定义一个变量接收其传出参数，避免readfds被更改</span><br><span class="line">		tmpfds=readfds;</span><br><span class="line">		nready=select(maxfd+1,&amp;tmpfds,NULL,NULL,NULL);</span><br><span class="line">		if(nready&lt;0)&#123;</span><br><span class="line">			if(errno==EINTR)//被信号打断</span><br><span class="line">				continue;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//有客户端连接到来</span><br><span class="line">		if(FD_ISSET(lfd,&amp;tmpfds))&#123;</span><br><span class="line">			//接收新连接</span><br><span class="line">			cfd=Accept(lfd,NULL,NULL);</span><br><span class="line">			</span><br><span class="line">			//将cfd加入到readfds集合中</span><br><span class="line">			FD_SET(cfd,&amp;readfds);</span><br><span class="line">			</span><br><span class="line">			//修改内核的监控范围</span><br><span class="line">			if(maxfd&lt;cfd)&#123;</span><br><span class="line">				maxfd=cfd;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			if(--nready==0)&#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		//有数据发来</span><br><span class="line">		for(i=lfd+1;i&lt;=maxfd;i++)&#123;</span><br><span class="line">			//判断文件描述符是否有变化</span><br><span class="line">			if(FD_ISSET(i,&amp;tmpfds))&#123;</span><br><span class="line">				//读数据</span><br><span class="line">				memset(buf,0x00,sizeof(buf));</span><br><span class="line">				n=Read(i,buf,sizeof(buf));</span><br><span class="line">				if(n&lt;=0)&#123;</span><br><span class="line">					//关闭连接</span><br><span class="line">					close(i);</span><br><span class="line">					//将i从readfds中删除，不需要内核监控该文件描述符了</span><br><span class="line">					FD_CLR(i,&amp;readfds);</span><br><span class="line">				&#125;</span><br><span class="line">				else&#123;</span><br><span class="line">					printf(&quot;n==[%d],buf=[%s]\n&quot;,n,buf);</span><br><span class="line">					</span><br><span class="line">					int k;</span><br><span class="line">					for(k=0;k&lt;n;k++)</span><br><span class="line">						buf[k]=toupper(buf[k]);</span><br><span class="line">					write(i,buf,n);</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				if(--nready==0)//nready是文件描述符变化的个数，只有一个变化，上面执行完，这里就可以break了，优化了程序</span><br><span class="line">					break;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	close(lfd);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select优点"><a href="#select优点" class="headerlink" title="select优点:"></a>select优点:</h2><p>1.一个进程可以支持多个客户端<br>2.select支持跨平台</p>
<h2 id="select缺点"><a href="#select缺点" class="headerlink" title="select缺点:"></a>select缺点:</h2><p>1.代码编写困难<br>2.会涉及到用户区到内核区的来回拷贝<br>3.当客户端多个连接, 但少数活跃的情况, select效率较低,因为select返回的只是变化的文件描述符个数，并没有指明具体是哪一个，需要遍历文件描述符表，进行判断！<br>例如: 作为极端的一种情况, 3-1023文件描述符全部打开, 但是只有1023有发送数据, select就显得效率低下<br>4.最大支持1024个客户端连接<br>select最大支持1024个客户端连接不是有文件描述符表最多可以支持1024个文件描述符限制的, 而是由FD_SETSIZE&#x3D;1024限制的.<br>FD_SETSIZE&#x3D;1024  fd_set使用了该宏, 当然可以修改内核, 然后再重新编译内核, 一般不建议这么做.</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/18/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/18/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++11可变参数模板（函数模板、类模板）</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-18 17:41:47 / 修改时间：17:57:35" itemprop="dateCreated datePublished" datetime="2022-05-18T17:41:47+08:00">2022-05-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="函数模板可变参数构造"><a href="#函数模板可变参数构造" class="headerlink" title="函数模板可变参数构造"></a>函数模板可变参数构造</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//函数可变参数模板的构造，C++11新特性</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//该空实现是递归构造的结束条件</span><br><span class="line">void myprint() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T,typename ...Args&gt;</span><br><span class="line">void myprint(const T&amp; firstarg, const Args &amp; ...args) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;fisrtarg:&quot; &lt;&lt; firstarg&lt;&lt;&quot; 参数类型：&quot; &lt;&lt; typeid(firstarg).name() &lt;&lt; &quot; 剩余的参数个数：&quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;</span><br><span class="line">	myprint(args...);//递归的构造！！！</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename ...Args&gt;</span><br><span class="line">void myprint(const Args &amp; ...args) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;print(....)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当较泛化和较特化的模板函数同时存在的时候，最终程序会执行较特化的那一个</span><br><span class="line">//也就是说，myprint(1, &quot;w&quot;, 2.6);选择的是较特化的，即：一个参数加可变参数的函数模板。而不选择泛化的，可变参数函数模板。</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	myprint(1, &quot;w&quot;, 2.6);</span><br><span class="line">	cout &lt;&lt; &quot;*****************&quot; &lt;&lt; endl;</span><br><span class="line">	string t = &quot;abc&quot;;</span><br><span class="line">	myprint(0.5, 0.6, 1, 2, t, &#x27;f&#x27;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fisrtarg:1 参数类型：int 剩余的参数个数：2</span><br><span class="line">fisrtarg:w 参数类型：char const [2] 剩余的参数个数：1</span><br><span class="line">fisrtarg:2.6 参数类型：double 剩余的参数个数：0</span><br><span class="line">*****************</span><br><span class="line">fisrtarg:0.5 参数类型：double 剩余的参数个数：5</span><br><span class="line">fisrtarg:0.6 参数类型：double 剩余的参数个数：4</span><br><span class="line">fisrtarg:1 参数类型：int 剩余的参数个数：3</span><br><span class="line">fisrtarg:2 参数类型：int 剩余的参数个数：2</span><br><span class="line">fisrtarg:abc 参数类型：class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; 剩余的参 数个数：1</span><br><span class="line">fisrtarg:f 参数类型：char 剩余的参数个数：0</span><br></pre></td></tr></table></figure>

<h2 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//利用可变参数的函数模板，实现多个数取最大值的操作，其中数的个数不定.</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//递归的结束条件</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T Max(T a, T b) &#123;</span><br><span class="line">	return (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">//只含有一个参数的特殊处理</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T Max(T a) &#123;</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//递归的进行比较</span><br><span class="line">template&lt;typename T,typename ...Args&gt;</span><br><span class="line">T Max(const T&amp; a, const Args &amp; ...args) &#123;</span><br><span class="line">	return Max(a, Max(args...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int re = Max(1,5);</span><br><span class="line">	cout &lt;&lt; re &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	int res = Max(1, 2, 5, 78);</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	int ret = Max(4, 2, 14);</span><br><span class="line">	cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	int r = Max(5);</span><br><span class="line">	cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果<br>5<br>78<br>14<br>5</li>
</ul>
<h2 id="类模板可变参数构造"><a href="#类模板可变参数构造" class="headerlink" title="类模板可变参数构造"></a>类模板可变参数构造</h2>
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/18/%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%E4%B8%8E%E5%81%8F%E7%89%B9%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/18/%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%E4%B8%8E%E5%81%8F%E7%89%B9%E5%8C%96/" class="post-title-link" itemprop="url">模板特化与偏特化</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-18 15:44:02 / 修改时间：17:27:54" itemprop="dateCreated datePublished" datetime="2022-05-18T15:44:02+08:00">2022-05-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="模板特化（template-specialization）不同于模板的实例化，模板参数在某种特定类型下的具体实现称为模板特化。模板特化有时也称之为模板的具体化，分别有函数模板特化和类模板特化。"><a href="#模板特化（template-specialization）不同于模板的实例化，模板参数在某种特定类型下的具体实现称为模板特化。模板特化有时也称之为模板的具体化，分别有函数模板特化和类模板特化。" class="headerlink" title="模板特化（template specialization）不同于模板的实例化，模板参数在某种特定类型下的具体实现称为模板特化。模板特化有时也称之为模板的具体化，分别有函数模板特化和类模板特化。"></a>模板特化（template specialization）不同于模板的实例化，模板参数在某种特定类型下的具体实现称为模板特化。模板特化有时也称之为模板的具体化，分别有函数模板特化和类模板特化。</h2><h2 id="函数模板全特化"><a href="#函数模板全特化" class="headerlink" title="函数模板全特化"></a>函数模板全特化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//函数模板特化</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//函数模板</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T Max(T a, T b) &#123;</span><br><span class="line">	return (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//进行特化,如果不对const char *类型进行特化，就会使用上面的模板函数，那时候，比较的是a,b的地址，而不是a,b。</span><br><span class="line">typedef const char* CH;</span><br><span class="line">template&lt;&gt; //在函数模板显示特化定义中，显示关键字template 和一对尖括号&lt;&gt;,然后是函数模板特化的定义。</span><br><span class="line">CH Max&lt;CH&gt;(CH a, CH b) &#123;</span><br><span class="line">	return (strcmp(a, b)) &gt; 0 ? a : b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//另一种方法是对Max进行重载，程序运行结果和使用函数模板特化相同。</span><br><span class="line">//typedef const char* CCP;</span><br><span class="line">//CCP Max(CCP s1, CCP s2) &#123;</span><br><span class="line">//	return (strcmp(s1, s2) &gt; 0) ? s1 : s2;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int  main() &#123;</span><br><span class="line"></span><br><span class="line">	int res = Max(1, 90);</span><br><span class="line">	const char* ret = Max&lt;const char*&gt;(&quot;very&quot;, &quot;good&quot;);</span><br><span class="line">	cout &lt;&lt; &quot;res=&quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;ret=&quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>运行结果<br>res&#x3D;90<br>ret&#x3D;very</li>
</ul>
<p>（1）如果使用普通重载函数，那么不管是否发生实际的函数调用，都会在目标文件中生成该函数的二进制代码。而如果使用模板的特化版本，除非发生函数调用，否则不会在目标文件中包含特化模板函数的二进制代码。这符合函数模板的“惰性实例化”准则。</p>
<p>（2）如果使用普通重载函数，那么在分离编译模式下，需要在各个源文件中包含重载函数的申明，否则在某些源文件中就会使用模板函数，而不是重载函数。</p>
<ul>
<li>所以使用特化版本的较好！！！</li>
</ul>
<h2 id="类模板全特化"><a href="#类模板全特化" class="headerlink" title="类模板全特化"></a>类模板全特化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//类模板特化</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//类模板</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">	T num;</span><br><span class="line">public:</span><br><span class="line">	A(T a):num(a) &#123;&#125;;</span><br><span class="line">	void print() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;num=&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//特化</span><br><span class="line">template&lt;&gt;</span><br><span class="line">class A&lt;const char *&gt; &#123;</span><br><span class="line">	const char* str;</span><br><span class="line">public:</span><br><span class="line">	A(const char *t):str(t) &#123;&#125;;</span><br><span class="line">	void print() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;str=&quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	A&lt;int&gt; a(1);</span><br><span class="line">	a.print();</span><br><span class="line">	const char* p = &quot;hello&quot;;</span><br><span class="line">	A&lt;const char*&gt;b(p);</span><br><span class="line">	b.print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>运行结果<br>num&#x3D;1<br>str&#x3D;hello</li>
</ul>
<h2 id="模板偏特化（Template-Partitial-Specialization）是模板特化的一种特殊情况，指显示指定部分模板参数而非全部模板参数，或者指定模板参数的部分特性分而非全部特性，也称为模板部分特化。与模板偏特化相对的是模板全特化，指对所有模板参数进行特化。模板全特化与模板偏特化共同组成模板特化"><a href="#模板偏特化（Template-Partitial-Specialization）是模板特化的一种特殊情况，指显示指定部分模板参数而非全部模板参数，或者指定模板参数的部分特性分而非全部特性，也称为模板部分特化。与模板偏特化相对的是模板全特化，指对所有模板参数进行特化。模板全特化与模板偏特化共同组成模板特化" class="headerlink" title="模板偏特化（Template Partitial Specialization）是模板特化的一种特殊情况，指显示指定部分模板参数而非全部模板参数，或者指定模板参数的部分特性分而非全部特性，也称为模板部分特化。与模板偏特化相对的是模板全特化，指对所有模板参数进行特化。模板全特化与模板偏特化共同组成模板特化."></a>模板偏特化（Template Partitial Specialization）是模板特化的一种特殊情况，指显示指定部分模板参数而非全部模板参数，或者指定模板参数的部分特性分而非全部特性，也称为模板部分特化。与模板偏特化相对的是模板全特化，指对所有模板参数进行特化。模板全特化与模板偏特化共同组成模板特化.</h2><h2 id="模板偏特化主要分为两种，一种是指对部分模板参数进行全特化，另一种是对模板参数特性进行特化，包括将模板参数特化为指针、引用或是另外一个模板类。"><a href="#模板偏特化主要分为两种，一种是指对部分模板参数进行全特化，另一种是对模板参数特性进行特化，包括将模板参数特化为指针、引用或是另外一个模板类。" class="headerlink" title="模板偏特化主要分为两种，一种是指对部分模板参数进行全特化，另一种是对模板参数特性进行特化，包括将模板参数特化为指针、引用或是另外一个模板类。"></a>模板偏特化主要分为两种，一种是指对部分模板参数进行全特化，另一种是对模板参数特性进行特化，包括将模板参数特化为指针、引用或是另外一个模板类。</h2><h2 id="函数模板不支持偏特化，利用函数重载即可。"><a href="#函数模板不支持偏特化，利用函数重载即可。" class="headerlink" title="函数模板不支持偏特化，利用函数重载即可。"></a>函数模板不支持偏特化，利用函数重载即可。</h2><h2 id="类模板偏特化"><a href="#类模板偏特化" class="headerlink" title="类模板偏特化"></a>类模板偏特化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">//类模板的偏特化</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//类模板，未特化的标准模板类不需要在类名后指定类型</span><br><span class="line">template&lt;typename T,typename N&gt;</span><br><span class="line">class test &#123;</span><br><span class="line">public:</span><br><span class="line">	static void compare(T a, N b) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;标准的类模板版本：&quot; &lt;&lt; endl;</span><br><span class="line">		if (a &gt; b) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot;b:&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot;&lt;=&quot; &lt;&lt; &quot;b:&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//对部分模板参数进行特化,注意需要在类名后指定类型！！！</span><br><span class="line">template&lt;typename N&gt;</span><br><span class="line">class test&lt;int,N&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">	static void compare(int a, N b) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;部分模板参数的特化：&quot; &lt;&lt; endl;</span><br><span class="line">		if (a &gt; b) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot;b:&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot;&lt;=&quot; &lt;&lt; &quot;b:&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//将模板参数特化为指针（对模板参数的特性进行特化）注意需要在类名后指定类型！！！</span><br><span class="line">template&lt;typename T,typename N&gt;</span><br><span class="line">class test&lt;T*,N*&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">	static void compare(T* a, N* b) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;对模板参数的特性进行特化：&quot; &lt;&lt; endl;</span><br><span class="line">		if (*a &gt; *b) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;a:&quot; &lt;&lt; *a &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot;b:&quot; &lt;&lt; *b &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;a:&quot; &lt;&lt; *a &lt;&lt; &quot;&lt;=&quot; &lt;&lt; &quot;b:&quot; &lt;&lt; *b &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//将模板参数特化为另一个模板类，注意需要在类名后指定类型！！！</span><br><span class="line">template&lt;typename T,typename N&gt;</span><br><span class="line">class test&lt;vector&lt;T&gt;,vector&lt;N&gt;&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">	static void compare(vector&lt;T&gt;&amp; a, vector&lt;N&gt;&amp; b) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;将模板参数特化为另一个模板类：&quot; &lt;&lt; endl;</span><br><span class="line">		if (a.size() &gt; b.size()) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;a.size():&quot; &lt;&lt; a.size() &lt;&lt; &quot;&gt;&quot; &lt;&lt; &quot;b.size():&quot; &lt;&lt; b.size() &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cout &lt;&lt; &quot;a.size():&quot; &lt;&lt; a.size() &lt;&lt; &quot;&lt;=&quot; &lt;&lt; &quot;b.size():&quot; &lt;&lt; b.size() &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	char a = &#x27;e&#x27;, b = &#x27;f&#x27;;</span><br><span class="line">	test&lt;char,char&gt;::compare(a, b);//因为compare方法是静态方法，所以，可以通过类名进行访问！</span><br><span class="line"></span><br><span class="line">	int c = 3;</span><br><span class="line">	char d = &#x27;a&#x27;;</span><br><span class="line">	test&lt;int,char&gt;::compare(c, d);</span><br><span class="line"></span><br><span class="line">	int e = 4, f = 7;</span><br><span class="line">	test&lt;int*,int*&gt;::compare(&amp;e, &amp;f);</span><br><span class="line"></span><br><span class="line">	vector&lt;int&gt;g&#123; 1,2,3 &#125;;</span><br><span class="line">	vector&lt;char&gt;h&#123; &#x27;a&#x27;,&#x27;b&#x27; &#125;;</span><br><span class="line"></span><br><span class="line">	test&lt;vector&lt;int&gt;,vector&lt;char&gt;&gt;::compare(g, h);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果<br>标准的类模板版本：<br>a:e&lt;&#x3D;b:f<br>部分模板参数的特化：<br>a:3&lt;&#x3D;b:a<br>对模板参数的特性进行特化：<br>a:4&lt;&#x3D;b:7<br>将模板参数特化为另一个模板类：<br>a.size():3&gt;b.size():2</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="全特化和偏特化组成了特化，注意函数没有偏特化！"><a href="#全特化和偏特化组成了特化，注意函数没有偏特化！" class="headerlink" title="全特化和偏特化组成了特化，注意函数没有偏特化！"></a>全特化和偏特化组成了特化，注意函数没有偏特化！</h2><h2 id="一个模板被称为全特化的条件：1-必须有一个主模板类-2-模板类型被全部明确化。"><a href="#一个模板被称为全特化的条件：1-必须有一个主模板类-2-模板类型被全部明确化。" class="headerlink" title="一个模板被称为全特化的条件：1.必须有一个主模板类  2.模板类型被全部明确化。"></a>一个模板被称为全特化的条件：1.必须有一个主模板类  2.模板类型被全部明确化。</h2><h2 id="偏特化的条件：1-必须有一个主模板-2-模板类型被部分明确化。"><a href="#偏特化的条件：1-必须有一个主模板-2-模板类型被部分明确化。" class="headerlink" title="偏特化的条件：1.必须有一个主模板   2.模板类型被部分明确化。"></a>偏特化的条件：1.必须有一个主模板   2.模板类型被部分明确化。</h2><h2 id="对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类-gt-偏特化类-gt-主版本模板类。这样的优先级顺序对性能也是最好的。"><a href="#对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类-gt-偏特化类-gt-主版本模板类。这样的优先级顺序对性能也是最好的。" class="headerlink" title="对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类&gt;偏特化类&gt;主版本模板类。这样的优先级顺序对性能也是最好的。"></a>对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类&gt;偏特化类&gt;主版本模板类。这样的优先级顺序对性能也是最好的。</h2>
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/10/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/10/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">网络编程</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-10 18:28:43" itemprop="dateCreated datePublished" datetime="2022-05-10T18:28:43+08:00">2022-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-19 20:23:55" itemprop="dateModified" datetime="2022-05-19T20:23:55+08:00">2022-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul>
<li>协议是双方共同指定的一组规则，在网络通信中表示双方传递数据和解释数据的一组规则.</li>
</ul>
<h3 id="典型协议"><a href="#典型协议" class="headerlink" title="典型协议"></a>典型协议</h3><ul>
<li><p>传输层 常见协议有TCP&#x2F;UDP协议。</p>
</li>
<li><p>应用层 常见的协议有HTTP协议，FTP协议。</p>
</li>
<li><p>网络层 常见协议有IP协议、ICMP协议、IGMP协议。</p>
</li>
<li><p>网络接口层 常见协议有ARP协议、RARP协议。</p>
</li>
<li><p>TCP传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
</li>
<li><p>UDP用户数据报协议（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>
</li>
<li><p>HTTP超文本传输协议（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议。</p>
</li>
<li><p>FTP文件传输协议（File Transfer Protocol）</p>
</li>
<li><p>IP协议是因特网互联协议（Internet Protocol）</p>
</li>
<li><p>ICMP协议是Internet控制报文协议（Internet Control Message Protocol）它是TCP&#x2F;IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</p>
</li>
<li><p>IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。</p>
</li>
<li><p>ARP协议是正向地址解析协议（Address Resolution Protocol），通过已知的IP，寻找对应主机的MAC地址。</p>
</li>
<li><p>RARP是反向地址转换协议，通过MAC地址确定IP地址。</p>
</li>
</ul>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>物数网传会表应<br><img src="/images/osi.png"></p>
<ul>
<li><p>物理层—双绞线，光纤（传输介质），将模拟信号转换为数字信号</p>
</li>
<li><p>数据链路层—数据校验，定义了网络传输的基本单位-帧 </p>
</li>
<li><p>网络层—定义网络，两台机器之间传输的路径选择点到点的传输</p>
</li>
<li><p>传输层—传输数据 TCP，UDP，端到端的传输  </p>
</li>
<li><p>会话层—通过传输层建立数据传输的通道. </p>
</li>
<li><p>表示层—编解码，翻译工作.</p>
</li>
<li><p>应用层—为客户提供各种应用服务，email服务，ftp服务，ssh服务</p>
</li>
</ul>
<h2 id="TCP-x2F-IP模型"><a href="#TCP-x2F-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h2><ul>
<li>TCP&#x2F;IP四层模型<br><img src="/images/osi.png"></li>
</ul>
<h2 id="数据通信过程"><a href="#数据通信过程" class="headerlink" title="数据通信过程"></a>数据通信过程</h2><ul>
<li>通信过程: 其实就是发送端层层打包, 接收方层层解包.</li>
</ul>
<p><img src="/images/data_com.png"></p>
<h2 id="网络应用程序常见的两种设计模式"><a href="#网络应用程序常见的两种设计模式" class="headerlink" title="网络应用程序常见的两种设计模式"></a>网络应用程序常见的两种设计模式</h2><ul>
<li><p>C&#x2F;S模式</p>
<p>  优点：可以安装在本地，可以缓存数据，协议选择灵活。<br>  缺点：客户端工具需要程序员开发，开发周期长工作量大；需要本地安装，对客户的电脑安全有一定影响。</p>
</li>
<li><p>B&#x2F;S模式（浏览器&#x2F;web服务器模式）<br>  优点：浏览器不用开发，开发周期短，移植性好，不受平台限制。<br>  缺点：协议只能选择htpp协议，协议选择受限，不能缓存数据，效率受影响。</p>
</li>
</ul>
<h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><ul>
<li><p>以太网帧格式就是包装在网络接口层(数据链路层)的协议<br><img src="/images/frame.png"></p>
</li>
<li><p>ARP协议：通过对方的IP地址获取MAC地址。<br>细节：目的端mac地址是通过发送端发送ARP广播, 接收到该ARP数据的主机先判断ARP帧中的目的ip是否是自己的IP。 若是则应答一个ARP应答报文, 并将自己的mac地址填入应答报文中; 若目的IP不是自己的主机IP, 则直接丢弃该ARP请求报文.</p>
</li>
</ul>
<h2 id="通过IP地址来确定网络环境中的唯一的一台主机"><a href="#通过IP地址来确定网络环境中的唯一的一台主机" class="headerlink" title="通过IP地址来确定网络环境中的唯一的一台主机;"></a>通过IP地址来确定网络环境中的唯一的一台主机;</h2><h2 id="主机上使用端口号来区分不同的应用程序"><a href="#主机上使用端口号来区分不同的应用程序" class="headerlink" title="主机上使用端口号来区分不同的应用程序."></a>主机上使用端口号来区分不同的应用程序.</h2><h2 id="IP-端口唯一确定唯一一台主机上的一个应用程序"><a href="#IP-端口唯一确定唯一一台主机上的一个应用程序" class="headerlink" title="IP+端口唯一确定唯一一台主机上的一个应用程序."></a>IP+端口唯一确定唯一一台主机上的一个应用程序.</h2><ul>
<li><p>常识端口：<br>21：ftp；<br>22：ssh；<br>23：telnet;<br>80:http;</p>
</li>
<li><p>TCP是稳定的, 安全的, 可靠的<br>  序号: TCP是安全可靠的, 每个数据包都带有序号, 当数据包丢失的时候, 需要重传, 要使用序号进行重传. 控制数据有序, 丢包重传.<br>  确认序号: 使用确认序号可以知道对方是否已经收到了, 通过确认序号可以知道哪个序号的数据需要重传.<br>16位窗口大小–滑动窗口(主要进行流量控制)，防止发送端发送过快，接收端接收慢，导致数据丢失。</p>
</li>
<li><p>IP协议:在网络层</p>
</li>
<li><p>TCP协议:面向连接的, 安全的,可靠的数据流传输协议.</p>
</li>
<li><p>UDP协议:面向无连接的, 不安全的,不可靠的数据报传输.</p>
</li>
</ul>
<h2 id="为什么TCP是安全可靠的连接？"><a href="#为什么TCP是安全可靠的连接？" class="headerlink" title="为什么TCP是安全可靠的连接？"></a>为什么TCP是安全可靠的连接？</h2><p>三次握手建立连接，四次挥手释放连接。<br><img src="/images/hand.PNG"></p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul>
<li><p>滑动窗口主要是进行流量控制的，防止发送端发送过快，接收端接受太慢，导致数据丢失。</p>
</li>
<li><p>如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会导致接收缓冲区满而丢失数据。TCP协议通过“滑动窗口（Sliding Window）”机制解决这一问题。<br><img src="/images/splid.png"></p>
</li>
<li><p>图中win表示告诉对方我这边缓冲区大小是多少, mss表示告诉对方我这边最多一次可以接收多少数据, 你最好不要超过这个长度.</p>
</li>
<li><p>在客户端给服务端发包的时候, 不一定是非要等到服务端返回响应包, 由于客户端知道服务端的窗口大小, 所以可以持续多次发送, 当发送数据达到对方窗口大小了就不再发送, 需要等到对方进行处理, 对方处理之后可继续发送.</p>
</li>
</ul>
<h2 id="MTU和MMS"><a href="#MTU和MMS" class="headerlink" title="MTU和MMS"></a>MTU和MMS</h2><ul>
<li>MTU，数据包的最大传输单元，默认是1500字节，超过这个大小，就会拆分数据包。那么MSS又是啥呢？MSS，最大数据段长度，不包括TCP和IP长度。可以这样简单的理解：MTU（1500字节）&#x3D;MSS（1460字节）+TCP（20字节）+IP(20字节)。</li>
</ul>
<h2 id="错误封装"><a href="#错误封装" class="headerlink" title="错误封装"></a>错误封装</h2><ul>
<li>阻塞函数在阻塞期间若收到信号, 会被信号中断, errno设置为EINTR,这个错误不应该看成一个错误.</li>
</ul>
<h2 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h2><p>粘包: 多次数据发送, 收尾相连, 接收端接收的时候不能正确区分第一次发送多少, 第二次发送多少。<br>解决方法：<br>1.报头+数据（最常用）：报头中包含数据长度。<br>2.添加结尾标志（不推荐，效率低，每次都要判断）<br>3.数据包定长（不灵活）</p>
<h2 id="高并发服务器"><a href="#高并发服务器" class="headerlink" title="高并发服务器"></a>高并发服务器</h2><h2 id="多进程版"><a href="#多进程版" class="headerlink" title="多进程版"></a>多进程版</h2><ul>
<li>问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">	cfd = accept();</span><br><span class="line">	</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		n = read(cfd, buf, sizeof(buf));</span><br><span class="line">		if(n&lt;=0)</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>这样写并不能真正实现并发，因为accept和read都是阻塞函数，当一个客户端连接服务器后，客户端不发送数据，那么服务器就会一直阻塞在read函数上，不能接受新的客户端连接！</p>
</li>
<li><p>解决办法1:<br>  将cfd设置为非阻塞: fcntl<br>  假如有多个客户端连接请求, cfd只会保留最后一个文件描述符的值，就会造成通信混乱，一样行不通。</p>
</li>
<li><p>解决方法2:<br>  使用多进程: 让父进程监听接受新的连接, 子进程处理新的连接(接收和发送数据);<br>  父进程还负责回收子进程</p>
</li>
</ul>
<p>处理流程:<br>    1 创建socket, 得到一个监听的文件描述符lfd—socket()<br>    2 将lfd和IP和端口port进行绑定—–bind();<br>    3 设置监听—-listen()<br>    4 进入while(1)<br>      {<br>          &#x2F;&#x2F;等待有新的客户端连接到来<br>          cfd &#x3D; accept();</p>
<pre><code>      //fork一个子进程, 让子进程去处理数据
      pid = fork();
      if(pid&lt;0)
      &#123;
          exit(-1);
      &#125;
      else if(pid&gt;0)
      &#123;
          //关闭通信文件描述符cfd
          close(cfd);
      &#125;
      else if(pid==0)
      &#123;
          //关闭监听文件描述符
          close(lfd);
          
          //收发数据
          while(1)
          &#123;
              //读数据
              n = read(cfd, buf, sizeof(buf));
              if(n&lt;=0)
              &#123;
                  break;
              &#125;
              
              //发送数据给对方
              write(cfd, buf, n);
          &#125;
          
          close(cfd);
          
          //下面的exit必须有, 防止子进程再去创建子进程
          exit(0);
      &#125;
  &#125;
  close(lfd);
</code></pre>
<p>还需要添加的功能: 父进程使用SIGCHLD信号完成对子进程的回收<br>注意点: accept或者read函数是阻塞函数, 会被信号打断, 此时不应该视为一个错误.errno&#x3D;EINTR</p>
<ul>
<li>父子进程能够共享的:<br>  文件描述符(子进程复制父进程的文件描述符)<br>  mmap共享映射区</li>
</ul>
<h2 id="多进程并发的服务器程序"><a href="#多进程并发的服务器程序" class="headerlink" title="多进程并发的服务器程序"></a>多进程并发的服务器程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">//服务器端程序</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;netinet/ip.h&gt; /* superset of previous */</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;	</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">#include&quot;wrap.h&quot; //自己实现的已经封装好的函数，含有错误处理</span><br><span class="line">#include&lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">void waitchild(int signo)&#123;</span><br><span class="line">	pid_t wpid;</span><br><span class="line">	</span><br><span class="line">	//循环回收子进程，当有多个子进程同时退出时，也可以全部回收，直到无子进程或者只存在正在运行的子进程</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		wpid=waitpid(-1,NULL,WNOHANG);//调用一次，只能回收一个子进程</span><br><span class="line">		if(wpid&gt;0)&#123;</span><br><span class="line">			printf(&quot;child exit,wpid=[%d]\n&quot;,wpid);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(wpid==0||wpid==-1)&#123;//子进程还在运行或者无子进程了，跳出循环</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	//创建socket</span><br><span class="line">	int lfd=Socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">	</span><br><span class="line">	//绑定</span><br><span class="line">	struct sockaddr_in addr;</span><br><span class="line">	bzero(&amp;addr,sizeof(addr));</span><br><span class="line">	addr.sin_family=AF_INET;</span><br><span class="line">	addr.sin_port=htons(1026);</span><br><span class="line">	addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">	</span><br><span class="line">	Bind(lfd,(struct sockaddr*)&amp;addr,sizeof(addr));</span><br><span class="line">	</span><br><span class="line">	//监听</span><br><span class="line">	Listen(lfd,128);</span><br><span class="line">	</span><br><span class="line">	//阻塞SIGCHLD信号，防止信号处理函数还未注册好，子进程就结束了，导致子进程的资源没有被回收</span><br><span class="line">	sigset_t mask;</span><br><span class="line">	sigemptyset(&amp;mask);</span><br><span class="line">	sigaddset(&amp;mask,SIGCHLD);</span><br><span class="line">	sigprocmask(SIG_BLOCK,&amp;mask,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	int cfd;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	struct sockaddr_in client;</span><br><span class="line">	socklen_t len;</span><br><span class="line">	char sip[16];</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		//接受新的连接</span><br><span class="line">		len=sizeof(client);</span><br><span class="line">		memset(&amp;sip,0x00,sizeof(sip));</span><br><span class="line">		cfd=Accept(lfd,(struct sockaddr *)&amp;client,&amp;len);</span><br><span class="line">		printf(&quot;client: ip==[%s],port=[%d]\n&quot;,inet_ntop(AF_INET,&amp;client.sin_addr.s_addr,sip,sizeof(sip)),ntohs(client.sin_port));</span><br><span class="line">		</span><br><span class="line">		//接受一个新的连接，就创建一个子进程，让子进程进行数据的收发</span><br><span class="line">		pid=fork();</span><br><span class="line">		if(pid&lt;0)&#123;</span><br><span class="line">			perror(&quot;fork failed...&quot;);</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(pid&gt;0)&#123;</span><br><span class="line">			//父进程关闭通信文件描述符，父进程只负责接受客户端的连接</span><br><span class="line">			close(cfd);</span><br><span class="line">			</span><br><span class="line">			//注册SIGCHLD信号处理函数</span><br><span class="line">			struct sigaction act;</span><br><span class="line">			act.sa_handler=waitchild;</span><br><span class="line">			act.sa_flags=0;</span><br><span class="line">			sigemptyset(&amp;act.sa_mask);</span><br><span class="line">			sigaction(SIGCHLD,&amp;act,NULL);</span><br><span class="line">			</span><br><span class="line">			//解除对SIGCHLD信号的阻塞</span><br><span class="line">			sigprocmask(SIG_UNBLOCK,&amp;mask,NULL);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		else if(pid==0)&#123;</span><br><span class="line">			//子进程关闭监听文件描述符</span><br><span class="line">			close(lfd);</span><br><span class="line">			int n;</span><br><span class="line">			char buf[1024];</span><br><span class="line">			int i;</span><br><span class="line">			while(1)&#123;</span><br><span class="line">				</span><br><span class="line">				n=Read(cfd,buf,sizeof(buf));</span><br><span class="line">				buf[n]=&#x27;\0&#x27;;</span><br><span class="line">				</span><br><span class="line">				printf(&quot;client ip=[%s], port=[%d] data: n==[%d],buf==[%s]\n&quot;,inet_ntop(AF_INET,&amp;client.sin_addr.s_addr,sip,sizeof(sip)),ntohs(client.sin_port),n,buf);</span><br><span class="line">				</span><br><span class="line">				if(n&lt;=0)&#123;</span><br><span class="line">					printf(&quot;read error or client closed,n==[%d]\n&quot;,n);</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				for(i=0;i&lt;n;i++)</span><br><span class="line">					buf[i]=toupper(buf[i]);</span><br><span class="line">				</span><br><span class="line">				Write(cfd,buf,n);</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">			close(cfd);</span><br><span class="line">			exit(0);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	close(lfd);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多线程并发服务器"><a href="#多线程并发服务器" class="headerlink" title="多线程并发服务器"></a>多线程并发服务器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">//服务器端程序</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;netinet/ip.h&gt; /* superset of previous */</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;	</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&quot;wrap.h&quot; //自己实现的已经封装好的函数，含有错误处理</span><br><span class="line"></span><br><span class="line">#define MAX_THREAD_NUM 1024</span><br><span class="line">struct INFO&#123;</span><br><span class="line">	int cfd;</span><br><span class="line">	int idx;</span><br><span class="line">	pthread_t threadID;</span><br><span class="line">	struct sockaddr_in client;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//设置最大接受的并发数，也就是子线程数</span><br><span class="line">//开辟内存，保证每一个线程使用的cfd不同，防止共享cfd，导致后面的覆盖前面的cfd</span><br><span class="line">struct INFO info[MAX_THREAD_NUM];</span><br><span class="line"></span><br><span class="line">void initthread_array()&#123;</span><br><span class="line">		int v;</span><br><span class="line">	for(v=0;v&lt;MAX_THREAD_NUM;v++)</span><br><span class="line">		info[v].cfd=-1;//cfd当作标志位，-1代表未使用，实现内存复用。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find_empty_thread_index()&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0;i&lt;MAX_THREAD_NUM;i++)&#123;</span><br><span class="line">		if(info[i].cfd==-1)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	if(i==MAX_THREAD_NUM)//达到最大线程数，就返回-1</span><br><span class="line">		return -1;</span><br><span class="line">	return i;//返回可用的线程索引</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//子线程回调函数</span><br><span class="line">void *thread_work(void *arg)&#123;</span><br><span class="line">	//注意用指针接受传入参数！！！因为在该回调函数中，最后需要更改my_info-&gt;cfd=-1!!!</span><br><span class="line">	//struct INFO my_info=*(struct INFO *)arg;这样接收参数，实际上是深拷贝，和传入的结构体不是同一块内存地址。</span><br><span class="line">	struct INFO *my_info=(struct INFO *)arg;</span><br><span class="line">	</span><br><span class="line">	int n;</span><br><span class="line">	char buf[1024];</span><br><span class="line">	int i;</span><br><span class="line">	printf(&quot;index==[%d]\n&quot;,my_info-&gt;idx);</span><br><span class="line">	char sIP[16];</span><br><span class="line">	printf(&quot;client ip==[%s],port==[%d]\n&quot;,inet_ntop(AF_INET,&amp;my_info-&gt;client.sin_addr.s_addr,sIP,sizeof(sIP)),ntohs(my_info-&gt;client.sin_port));</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		memset(&amp;buf,0x00,sizeof(buf));</span><br><span class="line">		n=Read(my_info-&gt;cfd,buf,sizeof(buf));</span><br><span class="line">		if(n&lt;=0)&#123;</span><br><span class="line">			printf(&quot;read error or client closed,n==[%d]\n&quot;,n);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;pthread_ID=[%ld] n==[%d],buf==[%s]\n&quot;,my_info-&gt;threadID,n,buf);</span><br><span class="line">		</span><br><span class="line">		for(i=0;i&lt;n;i++)</span><br><span class="line">			buf[i]=toupper(buf[i]);</span><br><span class="line">		//发送数据</span><br><span class="line">		Write(my_info-&gt;cfd,buf,n);</span><br><span class="line">	&#125;</span><br><span class="line">	close(my_info-&gt;cfd);</span><br><span class="line">	my_info-&gt;cfd=-1;//该处的线程id下次继续可以使用，实现内存复用</span><br><span class="line">	</span><br><span class="line">	pthread_exit(NULL);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	initthread_array();</span><br><span class="line">	//创建socket</span><br><span class="line">	int lfd=Socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">	</span><br><span class="line">	//设置端口复用</span><br><span class="line">	int opt = 1;</span><br><span class="line">	setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(int));</span><br><span class="line">	</span><br><span class="line">	//绑定</span><br><span class="line">	struct sockaddr_in addr;</span><br><span class="line">	bzero(&amp;addr,sizeof(addr));</span><br><span class="line">	addr.sin_family=AF_INET;</span><br><span class="line">	addr.sin_port=htons(1026);</span><br><span class="line">	addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">	</span><br><span class="line">	Bind(lfd,(struct sockaddr*)&amp;addr,sizeof(addr));</span><br><span class="line">	</span><br><span class="line">	//监听</span><br><span class="line">	Listen(lfd,128);</span><br><span class="line">	</span><br><span class="line">	int cfd;</span><br><span class="line">	int index;</span><br><span class="line">	int ret;</span><br><span class="line">	struct sockaddr_in client;</span><br><span class="line">	socklen_t len;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">				len=sizeof(client);</span><br><span class="line">				bzero(&amp;client,sizeof(client));</span><br><span class="line">				cfd=Accept(lfd,(struct sockaddr*)&amp;client,&amp;len);</span><br><span class="line">			</span><br><span class="line">				//在Info结构体数组中找一个可用的位置，返回其索引</span><br><span class="line">				index=find_empty_thread_index();</span><br><span class="line">				printf(&quot;******index=[%d]*****\n&quot;,index);</span><br><span class="line">				</span><br><span class="line">				if(index==-1)&#123;//线程id占满了，就拒绝继续创建子线程</span><br><span class="line">					printf(&quot;server busy!\n&quot;);</span><br><span class="line">					close(cfd);</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				//创建子线程</span><br><span class="line">				info[index].cfd=cfd;</span><br><span class="line">				memcpy(&amp;info[index].client,&amp;client,sizeof(client));</span><br><span class="line">				info[index].idx=index;</span><br><span class="line">				ret=pthread_create(&amp;info[index].threadID,NULL,thread_work,&amp;info[index]);</span><br><span class="line">				if(ret!=0)</span><br><span class="line">				&#123;</span><br><span class="line">					printf(&quot;create thread error:[%s]\n&quot;, strerror(ret));</span><br><span class="line">					exit(-1);</span><br><span class="line">				&#125;</span><br><span class="line">				//设置分离属性</span><br><span class="line">				pthread_detach(info[index].threadID);</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//关闭监听文件描述符</span><br><span class="line">	close(lfd);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/08/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/08/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">go语言基础（class 2）</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-08 20:38:20 / 修改时间：20:38:57" itemprop="dateCreated datePublished" datetime="2022-05-08T20:38:20+08:00">2022-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/03/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">守护进程和线程</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-03 21:04:58" itemprop="dateCreated datePublished" datetime="2022-05-03T21:04:58+08:00">2022-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-09 21:49:04" itemprop="dateModified" datetime="2022-05-09T21:49:04+08:00">2022-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="守护进程的特点"><a href="#守护进程的特点" class="headerlink" title="守护进程的特点:"></a>守护进程的特点:</h2><pre><code>1 一个linux后台服务进程
2 不依赖于控制终端
3 周期性执行某些任务
4 不受用户登录和注销的影响
5 一般以d结尾
</code></pre>
<h2 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话:"></a>进程组和会话:</h2><pre><code>进程组: 一个进程包含多个进程
会话: 多个组组成一个会话.

创建会话的进程不能是组长进程;
一般创建会话是父进程先fork子进程, 然后父进程退出, 让子进程调用setsid函数
创建一个会话, 这个子进程既是会长也是组长;
只要是创建了会话, 这个进程就脱离了控制终端的影响.
</code></pre>
<h2 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型:"></a>创建守护进程模型:</h2><pre><code>1 父进程fork子进程, 然后父进程退出.
   目的是: 子进程肯定不是组长进程, 为后续调用setsid函数提供了条件.
2 子进程调用setsid函数创建一个新的会话.
    1 该子进程成了该会话的会长
    2 该子进程成了该组的组长进程.
    3 不再受控制终端的影响了
3 改变当前的工作目录, chdir  -----不是必须的
4 重设文件掩码, umask(0000)  -----不是必须的
5 关闭STDIN_FILENO  STDOUT_FILENO STDERR_FILENO   ---不是必须的
6 核心操作
</code></pre>
<h2 id="编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。"><a href="#编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。" class="headerlink" title="编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。"></a>编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。</h2><p>分析：首先要按照1.3介绍的守护进行的步骤创建一个守护进程.<br>    每隔2S钟: 使用setitimer函数设置时钟, 该时钟发送的是SIGALRM信号,<br>    信号操作: 注册信号处理函数,signal或者sigaction, 还有一个信号处理函数<br>    获取一次系统时间: time函数的使用, ctime函数的使用<br>    写入磁盘文件: 文件操作函数: open write close </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//创建守护进程</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void clock_process(int signo)&#123;</span><br><span class="line">	</span><br><span class="line">	//0755文件权限指定，是配合O_CREAT使用的，如果没有该文件，则以0755权限创建文件</span><br><span class="line">	int fd=open(&quot;mydemo.log&quot;, O_RDWR|O_CREAT|O_APPEND,0755);</span><br><span class="line">	if(fd&lt;0)&#123;</span><br><span class="line">		//此时perror不能打印出错误，因为该进程已经摆脱了控制终端，无法输出到标准输出</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//获取当前的系统时间</span><br><span class="line">	time_t cur_time;</span><br><span class="line">	time(&amp;cur_time);</span><br><span class="line">	//转化为字符串</span><br><span class="line">	char *cur_time_s=ctime(&amp;cur_time);</span><br><span class="line">	//将时间写入文件</span><br><span class="line">	write(fd,cur_time_s,strlen(cur_time_s));</span><br><span class="line">	close(fd);</span><br><span class="line">	return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	pid_t pid=fork();</span><br><span class="line">	//父进程退出</span><br><span class="line">	if(pid&lt;0||pid&gt;0)&#123;</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//子进程创建会话</span><br><span class="line">	setsid();</span><br><span class="line">	</span><br><span class="line">	//改变当前的工作目录</span><br><span class="line">	chdir(&quot;/home/qcc/log&quot;);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//改变文件掩码</span><br><span class="line">	umask(0000);</span><br><span class="line">	</span><br><span class="line">	//关闭标准输入，标准输出，标准错误的文件描述符</span><br><span class="line">	close(STDOUT_FILENO);</span><br><span class="line">	close(STDIN_FILENO);</span><br><span class="line">	close(STDERR_FILENO);</span><br><span class="line">	</span><br><span class="line">	//核心操作</span><br><span class="line">	//注册信号处理函数</span><br><span class="line">	struct sigaction act;</span><br><span class="line">	act.sa_handler=clock_process;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	act.sa_flags=0;</span><br><span class="line">	sigaction(SIGALRM,&amp;act,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//设置时钟</span><br><span class="line">	struct itimerval tm;</span><br><span class="line">	//设置周期时间</span><br><span class="line">	tm.it_interval.tv_sec=2;</span><br><span class="line">	tm.it_interval.tv_usec=0;</span><br><span class="line">	//设置开始时间，3秒后</span><br><span class="line">	tm.it_value.tv_sec=3;</span><br><span class="line">	tm.it_value.tv_usec=0;</span><br><span class="line">	setitimer(ITIMER_REAL, &amp;tm, NULL);</span><br><span class="line">	</span><br><span class="line">	//该语句不会打印出来，因为子进程已经脱离了终端的控制</span><br><span class="line">	printf(&quot;hello world\n&quot;);</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优化:<br>    1 不再频繁的打开和关闭文件<br>    2 如何控制log文件大小  test.log</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">//创建守护进程</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int flag=0;//控制文件只打开一次</span><br><span class="line">int fd;</span><br><span class="line"></span><br><span class="line">void clock_process(int signo)&#123;</span><br><span class="line">	</span><br><span class="line">	//0755文件权限指定，是配合O_CREAT使用的，如果没有该文件，则以0755权限创建文件</span><br><span class="line">	</span><br><span class="line">	if(flag==0)&#123;</span><br><span class="line">		fd=open(&quot;mydemo.log&quot;, O_RDWR|O_CREAT|O_APPEND,0755);</span><br><span class="line">		if(fd&lt;0)&#123;</span><br><span class="line">			//此时perror不能打印出错误，因为该进程已经摆脱了控制终端，无法输出到标准输出</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		flag=1;</span><br><span class="line">	&#125;</span><br><span class="line">	//获取当前的系统时间</span><br><span class="line">	time_t cur_time;</span><br><span class="line">	time(&amp;cur_time);</span><br><span class="line">	//转化为字符串</span><br><span class="line">	char *cur_time_s=ctime(&amp;cur_time);</span><br><span class="line">	//将时间写入文件</span><br><span class="line">	write(fd,cur_time_s,strlen(cur_time_s));</span><br><span class="line">	</span><br><span class="line">	return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	pid_t pid=fork();</span><br><span class="line">	//父进程退出</span><br><span class="line">	if(pid&lt;0||pid&gt;0)&#123;</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//子进程创建会话</span><br><span class="line">	setsid();</span><br><span class="line">	</span><br><span class="line">	//改变当前的工作目录</span><br><span class="line">	chdir(&quot;/home/qcc/log&quot;);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//改变文件掩码</span><br><span class="line">	umask(0000);</span><br><span class="line">	</span><br><span class="line">	//关闭标准输入，标准输出，标准错误的文件描述符</span><br><span class="line">	close(STDOUT_FILENO);</span><br><span class="line">	close(STDIN_FILENO);</span><br><span class="line">	close(STDERR_FILENO);</span><br><span class="line">	</span><br><span class="line">	//核心操作</span><br><span class="line">	//注册信号处理函数</span><br><span class="line">	struct sigaction act;</span><br><span class="line">	act.sa_handler=clock_process;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	act.sa_flags=0;</span><br><span class="line">	sigaction(SIGALRM,&amp;act,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//设置时钟</span><br><span class="line">	struct itimerval tm;</span><br><span class="line">	//设置周期时间</span><br><span class="line">	tm.it_interval.tv_sec=2;</span><br><span class="line">	tm.it_interval.tv_usec=0;</span><br><span class="line">	//设置开始时间，3秒后</span><br><span class="line">	tm.it_value.tv_sec=3;</span><br><span class="line">	tm.it_value.tv_usec=0;</span><br><span class="line">	setitimer(ITIMER_REAL, &amp;tm, NULL);</span><br><span class="line">	</span><br><span class="line">	//该语句不会打印出来，因为子进程已经脱离了终端的控制</span><br><span class="line">	printf(&quot;hello world\n&quot;);</span><br><span class="line">	</span><br><span class="line">	int j=0;</span><br><span class="line">	char des[64];</span><br><span class="line">	char temp[10];</span><br><span class="line">	char *copy_file=&quot;./mydemo.log.bak&quot;;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		//获取文件大小</span><br><span class="line">		int size=lseek(fd,0,SEEK_END);</span><br><span class="line">		if(size&gt;100)&#123;//文件如果大于100，就保存一个副本！</span><br><span class="line">			close(fd);</span><br><span class="line">			j++;</span><br><span class="line">			memset(temp,0x00,sizeof(temp));</span><br><span class="line">			sprintf(temp,&quot;%d&quot;,j);//整数转为字符串</span><br><span class="line">			memset(des,0x00,sizeof(des));</span><br><span class="line">			sprintf(des,&quot;%s.%s&quot;,copy_file,temp);</span><br><span class="line">			rename(&quot;./mydemo.log&quot;,des);</span><br><span class="line">			flag=0;//保存副本了，下次需要重新打开文件</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	close(fd);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><ul>
<li><p>线程的基本概念<br><img src="/images/thread.png"></p>
</li>
<li><p>循环创建子线程<br><img src="/images/multithread.png"></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//循环创建子线程，并且打印是第几个子线程</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void *mythread(void *arg)&#123;</span><br><span class="line">	int *ret=(int *)arg;</span><br><span class="line">	printf(&quot;child thread num=[%d]\n&quot;,*ret);</span><br><span class="line">	printf(&quot;child thread,process_id=[%d],thread_id=[%ld]\n&quot;,getpid(),pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	pthread_t pid[5];</span><br><span class="line">	int n=5;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0;i&lt;n;i++)</span><br><span class="line">	&#123;	</span><br><span class="line">		int *temp=(int *)malloc(sizeof(int));</span><br><span class="line">		*temp=i;</span><br><span class="line">		int ret=pthread_create(&amp;pid[i],NULL,mythread,temp);</span><br><span class="line">		if(ret!=0)&#123;</span><br><span class="line">			printf(&quot;pthread_create failed. reason:[%s]\n&quot;,strerror(ret));</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;main thread,process_id=[%d],thread_id=[%ld]\n&quot;,getpid(),pthread_self());</span><br><span class="line">	</span><br><span class="line">	//目的是为了让子线程能执行起来，防止主线程结束后，子线程还未执行结束</span><br><span class="line">	sleep(1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ps-Lf-进程id"><a href="#ps-Lf-进程id" class="headerlink" title="ps -Lf 进程id"></a>ps -Lf 进程id</h3><p>查看进程中的所有线程</p>
<h2 id="线程相关函数"><a href="#线程相关函数" class="headerlink" title="线程相关函数:"></a>线程相关函数:</h2><pre><code>1 创建子线程: pthread_create
2 线程退出: pthread_exit
3 回收子线程: pthread_join
4 设置子线程为分离属性，设置后子线程会自己回收自己: pthread_detach
</code></pre>
<h2 id="进程和线程的函数比较"><a href="#进程和线程的函数比较" class="headerlink" title="进程和线程的函数比较"></a>进程和线程的函数比较</h2><p><img src="/images/compare.png"></p>
<h2 id="在创建线程的时候设置线程属性为分离属性-默认为非分离属性，传NULL即可"><a href="#在创建线程的时候设置线程属性为分离属性-默认为非分离属性，传NULL即可" class="headerlink" title="在创建线程的时候设置线程属性为分离属性(默认为非分离属性，传NULL即可):"></a>在创建线程的时候设置线程属性为分离属性(默认为非分离属性，传NULL即可):</h2><pre><code>1 pthread_attr_t attr;
2 pthread_attr_init(&amp;attr);
3 pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
4 pthread_create(&amp;thread, &amp;attr, mythread, NULL);
5 pthread_attr_destroy(&amp;attr);//最后记得释放属性内存
</code></pre>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li><p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p>
</li>
<li><p>两个线程数数分析：<br><img src="/images/num.png"></p>
</li>
<li><p>加锁解决</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">int num=0;</span><br><span class="line">void *mythread(void *arg)&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0;i&lt;10000;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		num++;</span><br><span class="line">		printf(&quot;pthread=[%ld]:num=[%d]\n&quot;,pthread_self(),num);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	pthread_t pid1;</span><br><span class="line">	pthread_t pid2;</span><br><span class="line">	</span><br><span class="line">	//初始化锁</span><br><span class="line">	pthread_mutex_init(&amp;mutex,NULL);</span><br><span class="line">	</span><br><span class="line">	int ret=pthread_create(&amp;pid1,NULL,mythread,NULL);</span><br><span class="line">	if(ret!=0)&#123;</span><br><span class="line">		printf(&quot;pthread_create failed. reason:[%s]\n&quot;,strerror(ret));</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	ret=pthread_create(&amp;pid2,NULL,mythread,NULL);</span><br><span class="line">	if(ret!=0)&#123;</span><br><span class="line">		printf(&quot;pthread_create failed. reason:[%s]\n&quot;,strerror(ret));</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	pthread_join(pid1,NULL);</span><br><span class="line">	pthread_join(pid2,NULL);</span><br><span class="line">	</span><br><span class="line">	//释放锁</span><br><span class="line">	pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好"><a href="#在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好" class="headerlink" title="在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好."></a>在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好.</h2><h2 id="互斥量-也叫互斥锁"><a href="#互斥量-也叫互斥锁" class="headerlink" title="互斥量(也叫互斥锁)"></a>互斥量(也叫互斥锁)</h2><pre><code>第1步：创建一把互斥锁
pthread_mutex_t mutex;
初始化互斥锁
pthread_mutex_init(&amp;mutex);---相当于mutex=1
在代码中寻找共享资源（也称为临界区）
pthread_mutex_lock(&amp;mutex);  -- mutex = 0
[临界区代码]
pthread_mutex_unlock(&amp;mutex); -- mutex = 1
释放互斥锁资源
pthread_mutex_destroy(&amp;mutex);
注意：必须在所有操作共享资源的线程上都加上锁否则不能起到同步的效果。
</code></pre>
<h2 id="死锁-死锁不是linux提供给开发者的一种机制-而是由于开发者操作不当引起的"><a href="#死锁-死锁不是linux提供给开发者的一种机制-而是由于开发者操作不当引起的" class="headerlink" title="死锁: 死锁不是linux提供给开发者的一种机制, 而是由于开发者操作不当引起的."></a>死锁: 死锁不是linux提供给开发者的一种机制, 而是由于开发者操作不当引起的.</h2><pre><code>1 自己锁自己.
    注意点: 线程在异常退出的时候也需要解锁.
2 A线程占用着A锁, 又想去获得B锁; B线程占用着B锁, 又想去获得A锁, 
  两个线程都不释放自己的锁, 又想去获得对方的锁, 从而造成了死锁.
  解决方法:
      1 需要先释放自己的锁再去获得其他锁
      2 避免使用嵌套的锁, 让线程按照一定的顺序加锁
      3 可以调用pthread_mutex_trylock函数加锁, 该函数不阻塞, 所以不会产生死锁.
</code></pre>
<h2 id="读写锁-读写锁是一把锁"><a href="#读写锁-读写锁是一把锁" class="headerlink" title="读写锁:读写锁是一把锁"></a>读写锁:读写锁是一把锁</h2><pre><code>读写锁场景练习:
线程A加写锁成功, 线程B请求读锁
    线程B阻塞, 
    当线程A解锁之后, 线程B加锁成功

线程A持有读锁, 线程B请求写锁
    线程B会阻塞;
    当线程A解锁之后, 线程B加锁成功

线程A拥有读锁, 线程B请求读锁
    线程B请求锁成功

线程A持有读锁, 然后线程B请求写锁, 然后线程C请求读锁
    线程B和C都阻塞;
    当A释放锁之后, B先获得锁, C阻塞
    当B释放锁之后, C获得锁    

线程A持有写锁, 然后线程B请求读锁, 然后线程C请求写锁
    线程B和C都阻塞;
    当线程A解锁之后, C先获得锁, B阻塞;
    当C解锁之后, B获得锁
</code></pre>
<h2 id="读写锁总结"><a href="#读写锁总结" class="headerlink" title="读写锁总结"></a>读写锁总结</h2><pre><code>写独占, 读共享, 当读和写一起等待锁的时候, 写的优先级高
</code></pre>
<h2 id="读写锁使用步骤"><a href="#读写锁使用步骤" class="headerlink" title="读写锁使用步骤:"></a>读写锁使用步骤:</h2><pre><code>1 先定义一把读写锁:
    pthread_rwlock_t rwlock;
2 初始化读写锁
    pthread_rwlock_init(&amp;rwlock, NULL);
3 加锁
    pthread_rwlock_rdlock(&amp;rwlock);----&gt;加读锁
    pthread_rwlock_wrlock(&amp;rwlock);----&gt;加写锁
    ////////////////////////
    共享资源出现的位置
    /////////////////////////
4 解锁
    pthread_rwlock_unlock(&amp;rwlock);
5 释放锁
    pthread_rwlock_destroy(&amp;rwlock);
</code></pre>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><ul>
<li>生产者消费者模型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct node&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">//创建虚拟头结点</span><br><span class="line">Node *dummy_head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pthread_cond_t cond;</span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"></span><br><span class="line">//生产者线程</span><br><span class="line">void *producer(void *arg)&#123;</span><br><span class="line">	</span><br><span class="line">	int no=*(int *)arg;</span><br><span class="line">	Node *p=NULL;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">	</span><br><span class="line">		//尾插法</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		Node *pnode=(Node *)malloc(sizeof(Node));</span><br><span class="line">		p=dummy_head;</span><br><span class="line">		pnode-&gt;data=rand()%1000;</span><br><span class="line">		</span><br><span class="line">		while(p-&gt;next!=NULL)&#123;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">		p-&gt;next=pnode;</span><br><span class="line">		pnode-&gt;next=NULL;</span><br><span class="line">		printf(&quot;producer=[%d],data=[%d]\n&quot;,no,pnode-&gt;data);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);	//注意先解锁，再通知消费者解除阻塞！！！</span><br><span class="line">		pthread_cond_signal(&amp;cond);//唤醒消费者</span><br><span class="line">		sleep(rand()%2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//消费者线程</span><br><span class="line">void *consumer(void *arg)&#123;</span><br><span class="line">	int no=*(int *)arg;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		//消费头结点的下一个节点</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		</span><br><span class="line">		//注意需要循环判断（如果是if，后面会空指针错误），因为可能多个消费者阻塞再cond上！！！</span><br><span class="line">		while(dummy_head-&gt;next==NULL)&#123;//链表为空，生产者阻塞</span><br><span class="line">			pthread_cond_wait(&amp;cond,&amp;mutex);//若条件不满足，则阻塞等待并释放锁；若条件满足，则解除阻塞并加锁！！！</span><br><span class="line">		&#125;</span><br><span class="line">		Node *pnode=dummy_head-&gt;next;</span><br><span class="line">		dummy_head-&gt;next=pnode-&gt;next;</span><br><span class="line">		printf(&quot;consumer=[%d],data=[%d]\n&quot;,no,pnode-&gt;data);</span><br><span class="line">		free(pnode);</span><br><span class="line">		pnode=NULL;</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		sleep(rand()%2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	dummy_head=(Node *)malloc(sizeof(Node));</span><br><span class="line">	dummy_head-&gt;data=0;</span><br><span class="line">	dummy_head-&gt;next=NULL;</span><br><span class="line">	pthread_t pthread[4];</span><br><span class="line">	</span><br><span class="line">	pthread_mutex_init(&amp;mutex,NULL);</span><br><span class="line">	pthread_cond_init(&amp;cond,NULL);</span><br><span class="line">	int i,j;</span><br><span class="line">	for(i=0;i&lt;2;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int *t=(int *)malloc(sizeof(int));</span><br><span class="line">		*t=i;</span><br><span class="line">		pthread_create(&amp;pthread[i],NULL,producer,t);</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	for(j=2;j&lt;4;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		int *tt=(int *)malloc(sizeof(int));</span><br><span class="line">		*tt=j;</span><br><span class="line">		pthread_create(&amp;pthread[j],NULL,consumer,tt);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int k;</span><br><span class="line">	</span><br><span class="line">	for(k=0;k&lt;4;k++)</span><br><span class="line">		pthread_join(pthread[k],NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">	pthread_cond_destroy(&amp;cond);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">//信号量，只适用于单生产者，单消费者模型。</span><br><span class="line">//出现多消费者多生产者，会出错！</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;semaphore.h&gt;</span><br><span class="line">typedef struct node&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">//创建虚拟头结点</span><br><span class="line">Node *dummy_head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sem_t sem_produce;</span><br><span class="line">sem_t sem_consumer;</span><br><span class="line"></span><br><span class="line">//生产者线程</span><br><span class="line">void *producer(void *arg)&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	Node *p=NULL;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">	</span><br><span class="line">		//尾插法</span><br><span class="line">		sem_wait(&amp;sem_consumer);</span><br><span class="line">		Node *pnode=(Node *)malloc(sizeof(Node));</span><br><span class="line">		p=dummy_head;</span><br><span class="line">		pnode-&gt;data=rand()%1000;</span><br><span class="line">		</span><br><span class="line">		while(p-&gt;next!=NULL)&#123;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">		p-&gt;next=pnode;</span><br><span class="line">		pnode-&gt;next=NULL;</span><br><span class="line">		printf(&quot;producer,data=[%d]\n&quot;,pnode-&gt;data);</span><br><span class="line">		sem_post(&amp;sem_produce);</span><br><span class="line">		sleep(rand()%2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//消费者线程</span><br><span class="line">void *consumer(void *arg)&#123;</span><br><span class="line">	</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		//消费头结点的下一个节点</span><br><span class="line">		sem_wait(&amp;sem_produce);</span><br><span class="line">		</span><br><span class="line">		Node *pnode=dummy_head-&gt;next;</span><br><span class="line">		dummy_head-&gt;next=pnode-&gt;next;</span><br><span class="line">		printf(&quot;consumer,data=[%d]\n&quot;,pnode-&gt;data);</span><br><span class="line">		free(pnode);</span><br><span class="line">		pnode=NULL;</span><br><span class="line">		sem_post(&amp;sem_consumer);</span><br><span class="line">		sleep(rand()%2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	dummy_head=(Node *)malloc(sizeof(Node));</span><br><span class="line">	dummy_head-&gt;data=0;</span><br><span class="line">	dummy_head-&gt;next=NULL;</span><br><span class="line">	pthread_t pthread1,pthread2;</span><br><span class="line">	</span><br><span class="line">	sem_init(&amp;sem_consumer,0,5);//控制最多可以连续生产的数量</span><br><span class="line">	sem_init(&amp;sem_produce,0,0);</span><br><span class="line">	</span><br><span class="line">	pthread_create(&amp;pthread1,NULL,producer,NULL);</span><br><span class="line">	pthread_create(&amp;pthread2,NULL,consumer,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	pthread_join(pthread1,NULL);</span><br><span class="line">	pthread_join(pthread2,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	sem_destroy(&amp;sem_consumer);</span><br><span class="line">	sem_destroy(&amp;sem_produce);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/01/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/01/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">进程通信</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-01 18:09:32" itemprop="dateCreated datePublished" datetime="2022-05-01T18:09:32+08:00">2022-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-03 19:21:09" itemprop="dateModified" datetime="2022-05-03T19:21:09+08:00">2022-05-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#进程间通信（IPC：interprocess communication）的概念<br>进程都有自己独立的地址空间，不能通过全局变量进行通信，要想进行通信，必须通过内核！<br>一个进行将数据写到内核缓冲区，另一个进程将数据读走。</p>
<ul>
<li>现在常用的进程间的通信方式有：<br>（1）管道（使用最简单）<br>（2）信号（开销最小）<br>（3）共享映射区（无血缘关系）<br>（4）本地套接字（最稳定）</li>
</ul>
<h2 id="管道–pipe"><a href="#管道–pipe" class="headerlink" title="管道–pipe"></a>管道–pipe</h2><p>管道是一种最基本的IPC机制，应用于有血缘关系的进程之间，完成数据传递。<br>（1）管道的本质是一块内核缓冲区<br>（2）由两个文件描述符引用，一个表示读端，一个表示写端。<br>（3）规定数据从管道的写端流入管道，从读端流出。<br>（4）当两个进程都终结的时候，管道也自动消失。<br>（5）管道的读端和写端默认都是阻塞的.</p>
<ul>
<li>管道的原理<br>（1）实质是内核缓冲区，内部实现是循环队列<br>（2）默认缓冲区大小为4k，使用ulimit -a查看<br>（3）实际操作过程中的缓冲区会根据数据压力做适当调整</li>
<li>管道的局限性<br>（1）数据一旦被读走，便不在管道中存在，不可反复读取。<br>（2）数据只能在一个方向上流动，若要实现双向流动，必须使用两个管道<br>（3）只能在有血缘关系的进程间使用管道。</li>
</ul>
<h2 id="补充知识：指针类型的变量，是来存放地址的，那么它当然等于计算机内部地址总线的宽度。所以在32位计算机中，一个指针变量的返回值必定是4（注意结果是以字节为单位，在64位系统中指针变量的sizeof结果为8。"><a href="#补充知识：指针类型的变量，是来存放地址的，那么它当然等于计算机内部地址总线的宽度。所以在32位计算机中，一个指针变量的返回值必定是4（注意结果是以字节为单位，在64位系统中指针变量的sizeof结果为8。" class="headerlink" title="补充知识：指针类型的变量，是来存放地址的，那么它当然等于计算机内部地址总线的宽度。所以在32位计算机中，一个指针变量的返回值必定是4（注意结果是以字节为单位，在64位系统中指针变量的sizeof结果为8。"></a>补充知识：指针类型的变量，是来存放地址的，那么它当然等于计算机内部地址总线的宽度。所以在32位计算机中，一个指针变量的返回值必定是4（注意结果是以字节为单位，在64位系统中指针变量的sizeof结果为8。</h2><h2 id="pipe用于父子进程间的通信过程"><a href="#pipe用于父子进程间的通信过程" class="headerlink" title="pipe用于父子进程间的通信过程"></a>pipe用于父子进程间的通信过程</h2><p>(1)父进程创建pipe<br>(2)父进程调用fork函数创建子进程<br>(3)父进程关闭一端（读&#x2F;写），子进程关闭另一端（写&#x2F;读）。<br>(4)父子进程分别执行read和write函数<br>注意：如果都要读&#x2F;写，则需要创建两个pipe!!!</p>
<h2 id="ps-aux-grep-bash的实现原理-pipe的应用"><a href="#ps-aux-grep-bash的实现原理-pipe的应用" class="headerlink" title="ps aux|grep bash的实现原理(pipe的应用)"></a>ps aux|grep bash的实现原理(pipe的应用)</h2><p><img src="/images/ps_aux.png"></p>
<ul>
<li>父子通信</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int fd[2];</span><br><span class="line">	int ret=pipe(fd);</span><br><span class="line">	if(ret==-1)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;pipe error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	pid_t pid=fork();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	if(pid&gt;0)&#123;</span><br><span class="line">		close(fd[0]);//关闭读</span><br><span class="line">		int res=dup2(fd[1],STDOUT_FILENO);//标准输出重定向</span><br><span class="line">		if(res==-1)&#123;</span><br><span class="line">			perror(&quot;dup2 error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;aux&quot;,NULL);//拉起一个应用程序，直接替换代码段，成功执行后，该语句后面的不会执行。</span><br><span class="line">		perror(&quot;execlp error&quot;);</span><br><span class="line">		wait(NULL);//阻塞回收子进程，当execlp执行失败，则会执行</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid==0)&#123;</span><br><span class="line">		close(fd[1]);//关闭写</span><br><span class="line">		int re=dup2(fd[0],STDIN_FILENO);</span><br><span class="line">		if(re==-1)&#123;</span><br><span class="line">			perror(&quot;dup2 error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		execlp(&quot;grep&quot;,&quot;grep&quot;,&quot;--color=auto&quot;,&quot;bash&quot;,NULL);</span><br><span class="line">		perror(&quot;execlp error&quot;);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>兄弟通信</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int fd[2];</span><br><span class="line">	int ret=pipe(fd);</span><br><span class="line">	if(ret==-1)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;pipe error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0;i&lt;2;i++)&#123;</span><br><span class="line">		pid_t pid=fork();	</span><br><span class="line">		if(pid&lt;0)&#123;</span><br><span class="line">			perror(&quot;fork error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(pid&gt;0)&#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(pid==0)&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(i==2)&#123;</span><br><span class="line">		close(fd[0]);//父进程关闭读写，只用于回收子进程</span><br><span class="line">		close(fd[1]);</span><br><span class="line">		while(1)&#123;</span><br><span class="line">			pid_t wpid=waitpid(-1,NULL,WNOHANG);</span><br><span class="line">			if(wpid==0)</span><br><span class="line">				continue;</span><br><span class="line">			else if(wpid==-1)//无子进程了，退出</span><br><span class="line">				exit(0);</span><br><span class="line">			else if(wpid&gt;0)&#123;</span><br><span class="line">				printf(&quot;recover child pid=[%d]\n&quot;,wpid);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	if(i==0)&#123;</span><br><span class="line">		printf(&quot;child 1,pid=[%d],ppid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">		close(fd[0]);</span><br><span class="line">		int ret=dup2(fd[1],STDOUT_FILENO);</span><br><span class="line">		if(ret==-1)&#123;</span><br><span class="line">			perror(&quot;dup2 error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		execlp(&quot;ps&quot;,&quot;ps&quot;,&quot;aux&quot;,NULL);</span><br><span class="line">		perror(&quot;execlp error&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	if(i==1)&#123;</span><br><span class="line">		printf(&quot;child 2,pid=[%d],ppid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">		close(fd[1]);</span><br><span class="line">		int res=dup2(fd[0],STDIN_FILENO);</span><br><span class="line">		if(res==-1)&#123;</span><br><span class="line">			perror(&quot;dup2 error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		execlp(&quot;grep&quot;,&quot;grep&quot;,&quot;bash&quot;,NULL);</span><br><span class="line">		perror(&quot;execlp error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#FIFO</p>
<ul>
<li><p>FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间通信。但通过FIFO，不相关的进程也能交换数据.</p>
</li>
<li><p>fifo进程通信原理<br><img src="/images/fifo.png"></p>
</li>
<li><p>fifo完成两个进程间的通信思路<br>进程A：<br>（1）创建一个fifo文件：mkfifo命令或者使用mkfifo函数。<br>（2）open fifo文件，获得一个文件描述符。<br>（3）写fifo文件<br>（4）关闭fifo文件<br>进程B：<br>（1）打开fifo文件，获得文件描述符。<br>（2）读fifo文件<br>（3）关闭fifo文件</p>
</li>
<li><p>注意：使用open打开FIFO文件</p>
</li>
</ul>
<p>1.FIFO命名管道不能以O_RDWR的模式打开，会产生二义性。（通常使用FIFO只是为了单向传递数据）</p>
<p>2.如果确定需要程序之间双向传递数据。<br>①最好使用一对FIFO或者管道，一个方向使用一个！！！<br>②采用先关闭再重新打开FIFO的方法来明确地改变数据流的去向（不常用）。</p>
<h3 id="只写阻塞方式打开fifo文件，在写入数据时，若没有进程在另一端读，则阻塞，直至有进程读。"><a href="#只写阻塞方式打开fifo文件，在写入数据时，若没有进程在另一端读，则阻塞，直至有进程读。" class="headerlink" title="只写阻塞方式打开fifo文件，在写入数据时，若没有进程在另一端读，则阻塞，直至有进程读。"></a>只写阻塞方式打开fifo文件，在写入数据时，若没有进程在另一端读，则阻塞，直至有进程读。</h3><p>通过两个fifo文件，实现两个进程之间的相互读写（阻塞方式）。</p>
<ul>
<li>进程A：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//fifo完成进程间通信的测试</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">		//创建fifo文件</span><br><span class="line">	int res=access(&quot;./myfifo_2&quot;,F_OK);//测试文件是否存在,返回0存在</span><br><span class="line">	if(res!=0)&#123;</span><br><span class="line">		int ret=mkfifo(&quot;./myfifo_2&quot;,0777);</span><br><span class="line">		if(ret==-1)&#123;</span><br><span class="line">			perror(&quot;mkfifo error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int fd1=open(&quot;./myfifo&quot;,O_RDONLY);</span><br><span class="line">	int fd2=open(&quot;./myfifo_2&quot;,O_WRONLY);</span><br><span class="line">	if(fd1&lt;0||fd2&lt;0)&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//读myfifo文件</span><br><span class="line">	char buf[256];</span><br><span class="line">	memset(buf,0x00,sizeof(buf));</span><br><span class="line">	int len=read(fd1,buf,sizeof(buf));</span><br><span class="line">	printf(&quot;len=[%d],buf=[%s]\n&quot;,len,buf);</span><br><span class="line">	close(fd1);</span><br><span class="line">	//写myfifo_2文件</span><br><span class="line">	write(fd2,&quot;ni hao&quot;,sizeof(&quot;ni hao&quot;));</span><br><span class="line">	close(fd2);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>进程B</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//fifo完成进程间通信的测试</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//创建fifo文件</span><br><span class="line">	int res=access(&quot;./myfifo&quot;,F_OK);//测试文件是否存在,返回0存在</span><br><span class="line">	if(res!=0)&#123;</span><br><span class="line">		int ret=mkfifo(&quot;./myfifo&quot;,0777);</span><br><span class="line">		if(ret==-1)&#123;</span><br><span class="line">			perror(&quot;mkfifo error&quot;);</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	int fd1=open(&quot;./myfifo&quot;,O_WRONLY);</span><br><span class="line">	int fd2=open(&quot;./myfifo_2&quot;,O_RDONLY);</span><br><span class="line">	if(fd1&lt;0||fd2&lt;0)&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//写myfifo文件</span><br><span class="line">	write(fd1,&quot;hello world&quot;,strlen(&quot;hello world&quot;));</span><br><span class="line">	close(fd1);</span><br><span class="line">	</span><br><span class="line">	//读myfifo_2文件</span><br><span class="line">	char buf[256];</span><br><span class="line">	memset(buf,0x00,sizeof(buf));</span><br><span class="line">	int len=read(fd2,buf,sizeof(buf));</span><br><span class="line">	printf(&quot;len=[%d],buf=[%s]\n&quot;,len,buf);</span><br><span class="line">	close(fd2);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="共享映射区"><a href="#共享映射区" class="headerlink" title="共享映射区"></a>共享映射区</h1><ul>
<li><p>存储映射I&#x2F;O (Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。从缓冲区中取数据，就相当于读文件中的相应字节；将数据写入缓冲区，则会将数据写入文件。这样，就可在不使用read和write函数的情况下，使用地址（指针）完成I&#x2F;O操作<br><img src="/images/mmap.png"></p>
</li>
<li><p>函数原型：<br>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);<br>参数：<br>addr:一般传NULL,表示让内核去指定一个内存的起始地址<br>length:文件大小（lseek或者stat函数获取）<br>prot:PROT_READ;PROT_WRITE;PROT_READ|PROT_WRITE<br>flags:<br>MAP_SHARED:对映射区的修改会反映到文件中（可以对文件进行修改).<br>MAP_PRIVATE:可以读文件中的数据，但是写不进去数据，即使向内存中也写不进去数据。<br>fd:打开的文件描述符<br>offset:从文件的哪个位置开始映射，一般为0.<br>返回值：映射区的首地址。</p>
</li>
<li><p>实现父子进程之间的通信</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//利用mmap函数完成父子进程间通信</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//使用mmap函数建立共享映射区</span><br><span class="line">	//void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="line">	int fd=open(&quot;./test.log&quot;,O_RDWR);</span><br><span class="line">	if(fd&lt;0)&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	int len=lseek(fd,0,SEEK_END);//获取文件大小</span><br><span class="line"></span><br><span class="line">	//void *addr=mmap(NULL,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</span><br><span class="line">	void *addr=mmap(NULL,len,PROT_READ|PROT_WRITE,MAP_PRIVATE,fd,0);</span><br><span class="line">	if(addr==MAP_FAILED)&#123;</span><br><span class="line">		perror(&quot;mmap error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	pid_t pid=fork();</span><br><span class="line">	if(pid&lt;0)&#123;</span><br><span class="line">		perror(&quot;fork error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid&gt;0)&#123;</span><br><span class="line">		memcpy(addr,&quot;hello world&quot;,strlen(&quot;hello world&quot;));//设置为MAP_PRIVATE,向内存中写不进去数据</span><br><span class="line">		wait(NULL);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid==0)&#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">		char *p=(char *)addr;//可以读文件中的数据</span><br><span class="line">		printf(&quot;[%s]\n&quot;,p);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>实现无血缘关系的进程之间的通信</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//利用mmap函数完成进程间通信(write)</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//使用mmap函数建立共享映射区</span><br><span class="line">	//void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="line">	int fd=open(&quot;./test.log&quot;,O_RDWR);</span><br><span class="line">	if(fd&lt;0)&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	int len=lseek(fd,0,SEEK_END);//获取文件大小</span><br><span class="line"></span><br><span class="line">	void *addr=mmap(NULL,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</span><br><span class="line">	</span><br><span class="line">	if(addr==MAP_FAILED)&#123;</span><br><span class="line">		perror(&quot;mmap error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	memcpy(addr,&quot;0123456789&quot;,10);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//利用mmap函数完成进程间通信(read)</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//使用mmap函数建立共享映射区</span><br><span class="line">	//void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="line">	int fd=open(&quot;./test.log&quot;,O_RDWR);</span><br><span class="line">	if(fd&lt;0)&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	int len=lseek(fd,0,SEEK_END);//获取文件大小</span><br><span class="line"></span><br><span class="line">	void *addr=mmap(NULL,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</span><br><span class="line">	</span><br><span class="line">	if(addr==MAP_FAILED)&#123;</span><br><span class="line">		perror(&quot;mmap error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	char buf[64];</span><br><span class="line">	memset(buf,0x00,sizeof(buf));</span><br><span class="line">	memcpy(buf,addr,10);</span><br><span class="line">	printf(&quot;buf=[%s]\n&quot;,buf);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>使用mmap函数建立匿名映射(只能用与有血缘关系的进程)：<br>mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</li>
</ul>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><ul>
<li><p>每个进程收到的所有信号，都是由内核负责发送的。<br>进程A给进程B发送信号原理示意图：<br><img src="/images/mmap.png"></p>
</li>
<li><p>signal函数使用</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void sighandler(int signo)&#123;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;signo=[%d]\n&quot;,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	int fd[2];</span><br><span class="line">	int ret=pipe(fd);</span><br><span class="line">	if(ret&lt;0)&#123;</span><br><span class="line">		perror(&quot;pipe error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//注册信号处理函数，当触发SIGPIPE信号时，内核就会回调用户定义好的回调函数，执行回调函数的内容</span><br><span class="line">	signal(SIGPIPE,sighandler);</span><br><span class="line">	</span><br><span class="line">	close(fd[0]);//关闭读端</span><br><span class="line">	write(fd[1],&quot;1213&quot;,strlen(&quot;1213&quot;));//往管道里写数据，因为没有读端，系统会发送一个SIGPIPE信号</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>信号的特点：简单，不挟带大量信息，满足某个特定条件产生</p>
</li>
<li><p>信号的产生: 按键（Ctrl+c、Ctrl+z、Ctrl+\）；系统调用。。。</p>
</li>
<li><p>信号的状态: 产生，未决，递达</p>
</li>
<li><p>信号的四要素：<br>信号的编号<br>信号的名字<br>信号的默认处理动作<br>信号是如何产生的（产生原因）</p>
</li>
<li><p>signal函数: 给内核注册信号处理函数</p>
</li>
<li><p>kill: 发送指定信号给指定进程<br>kill函数原型：int kill(pid_t pid, int sig);<br>函数返回值：<br>成功：0；<br>失败：-1，设置errno</p>
</li>
</ul>
<h3 id="特别需要注意的是：The-signals-SIGKILL-and-SIGSTOP-cannot-be-caught-blocked-or-ignored"><a href="#特别需要注意的是：The-signals-SIGKILL-and-SIGSTOP-cannot-be-caught-blocked-or-ignored" class="headerlink" title="特别需要注意的是：The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored."></a>特别需要注意的是：The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</h3><h3 id="几个常用到的信号"><a href="#几个常用到的信号" class="headerlink" title="几个常用到的信号"></a>几个常用到的信号</h3><p>SIGINT、SIGQUIT、SIGKILL、SIGSEGV、SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM、SIGTERM、SIGCHLD、SIGSTOP、SIGCONT</p>
<ul>
<li><p>alarm:<br>  1 每一个进程都只有一个时钟，后一个的时钟设置会覆盖上一个时钟！！！<br>  2 alarm函数的返回值: 0 或者是上一个alarm剩余的秒数<br>  3 alarm(0): 取消定时器<br>  4 alarm函数发送的是SIGALRM信号，作用是term，终止进程.</p>
</li>
<li><p>使用time命令查看程序执行的时间。程序运行的瓶颈在于IO，优化程序，首选优化IO。</p>
</li>
<li><p>实际执行时间 &#x3D; 系统时间 + 用户时间 + 损耗时间<br>损耗的时间主要来来自文件IO操作，IO操作会有用户区到内核区的切换，切换的次数越多越耗时。</p>
</li>
</ul>
<h2 id="闹钟"><a href="#闹钟" class="headerlink" title="闹钟"></a>闹钟</h2><ul>
<li><p>实际执行时间 &#x3D; 系统时间 + 用户时间 + 损耗时间</p>
</li>
<li><p>损耗时间&#x3D; 实际执行时间-(系统时间 + 用户时间 )</p>
</li>
<li><p>每一个数字都直接打印:printf(“[%d]\n”, i++);<br>real    0m1.217s<br>user    0m0.120s<br>sys     0m0.252s<br>15734次<br>损耗时间&#x3D; 1.217-(0.120+0.252)&#x3D;0.845</p>
</li>
<li><p>文件重定向之后:<br>time .&#x2F;alarm_uncle  &gt; test.log<br>real    0m1.003s<br>user    0m0.520s<br>sys     0m0.428s<br>2191879次<br>损耗时间&#x3D;1.003-(0.520+0.428)&#x3D;0.055</p>
</li>
<li><p>原因是: 调用printf函数打印数字遇到\n才会打印, 打印过程涉及到从用户区到内核区的切换, 切换次数越多消耗的时间越长, 效率越低;而使用文件重定向, 由于文件操作是带缓冲的, 所以涉及到用户区到内核区的<br>切换次数大大减少,从而使损耗降低.</p>
</li>
<li><p>setitimer函数的功能: 设置时钟, 能够周期性的触发时钟<br>int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);</p>
</li>
<li><p>使用setitimer实现从第三秒开始，每隔一秒打印一次signo。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//setitimer函数测试</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">void sighander(int signo)&#123;</span><br><span class="line">	printf(&quot;signo=[%d]\n&quot;,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	 //int setitimer(int which, const struct itimerval *new_value,</span><br><span class="line">       //              struct itimerval *old_value);</span><br><span class="line">	</span><br><span class="line">	//注册信号处理函数</span><br><span class="line">	signal(SIGALRM,sighander);</span><br><span class="line">	</span><br><span class="line">	struct itimerval tm;</span><br><span class="line">	//周期性时间赋值</span><br><span class="line">	tm.it_interval.tv_sec=1;//秒</span><br><span class="line">	tm.it_interval.tv_usec=0;//微秒</span><br><span class="line">	//第一次触发的时间</span><br><span class="line">	tm.it_value.tv_sec=3;</span><br><span class="line">	tm.it_value.tv_usec=0;</span><br><span class="line">	</span><br><span class="line">	setitimer(ITIMER_REAL,&amp;tm,NULL);</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><ul>
<li>未决信号集和阻塞信号集<br><img src="/images/sigset.png"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//每隔十次解除对SIGINT和SIGQUIT的阻塞，就能捕获到这两个信号，执行回调函数</span><br><span class="line">//信号集</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void sighander(int signo)&#123;</span><br><span class="line">	printf(&quot;signo=[%d]\n&quot;,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	signal(SIGINT,sighander);</span><br><span class="line">	signal(SIGQUIT,sighander);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//定义信号集变量</span><br><span class="line">	sigset_t set;</span><br><span class="line">	sigset_t oldset;</span><br><span class="line">	</span><br><span class="line">	//初始化信号集</span><br><span class="line">	sigemptyset(&amp;set);</span><br><span class="line">	sigemptyset(&amp;oldset);</span><br><span class="line">	</span><br><span class="line">	//将SIGINT(ctrl+c)和SIGQUIT(ctrl+\)加入到集合中</span><br><span class="line">	sigaddset(&amp;set,SIGINT);</span><br><span class="line">	sigaddset(&amp;set,SIGQUIT);</span><br><span class="line">	</span><br><span class="line">	//将SIGINT和SIGQUIT加入到阻塞集中</span><br><span class="line">	//int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="line">	sigprocmask(SIG_BLOCK,&amp;set,&amp;oldset);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	sigset_t pending;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	int j=0;</span><br><span class="line">	</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		</span><br><span class="line">		sigemptyset(&amp;pending);//初始化</span><br><span class="line">		</span><br><span class="line">		//获取未决信号集</span><br><span class="line">		sigpending(&amp;pending);</span><br><span class="line">		int i;</span><br><span class="line">		for(i=1;i&lt;32;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(sigismember(&amp;pending,i)==1)</span><br><span class="line">				printf(&quot;1&quot;);</span><br><span class="line">			else</span><br><span class="line">				printf(&quot;0&quot;);</span><br><span class="line">				</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		sleep(1);</span><br><span class="line">		j++;</span><br><span class="line">		//每循环10次，就解除一次对SIGINT和SIGQUIT的阻塞</span><br><span class="line">		if(j%10==0)&#123;</span><br><span class="line">			//sigprocmask(SIG_UNBLOCK,&amp;set,NULL);</span><br><span class="line">			sigprocmask(SIG_SETMASK,&amp;oldset,NULL);</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			sigprocmask(SIG_BLOCK,&amp;set,NULL);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号捕捉函数"><a href="#信号捕捉函数" class="headerlink" title="信号捕捉函数"></a>信号捕捉函数</h2><ul>
<li><p>在xxx信号处理函数执行期间, 若xxx信号再次产生多次, 则信号处理函数不会被打断,当信号处理函数执行完以后, 后来产生的信号只会被处理一次.<br>信号不支持排队.  </p>
</li>
<li><p>在xxx信号处理函数执行期间(前提是sa_mask中阻塞了yyy信号), 若收到了yyy信号, 则yyy信号会被阻塞(暂时被阻塞（和阻塞集无关）！！！), 当xxx信号处理函数执行完毕后, 则yyy信号只会被处理一次.</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void sighandler(int signo)&#123;</span><br><span class="line">	printf(&quot;signo=-[%d]\n&quot;,signo);</span><br><span class="line">	sleep(3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	//注册信号处理函数</span><br><span class="line">	struct sigaction act;</span><br><span class="line">	act.sa_handler=sighandler;//信号处理函数</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);//阻塞的信号</span><br><span class="line">	//sigaddset(&amp;act.sa_mask,SIGQUIT);//在信号处理函数执行期间阻塞SIGQUIT信号</span><br><span class="line">	act.sa_flags=0;</span><br><span class="line">	sigaction(SIGINT,&amp;act,NULL);</span><br><span class="line">	</span><br><span class="line">	signal(SIGQUIT,sighandler);</span><br><span class="line">	</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SIGCHLD信号（重点！！！注意理解）"><a href="#SIGCHLD信号（重点！！！注意理解）" class="headerlink" title="SIGCHLD信号（重点！！！注意理解）"></a>SIGCHLD信号（重点！！！注意理解）</h2><ul>
<li>SIGCHLD信号:</li>
</ul>
<p>1 SIGCHLD信号产生的条件:<br>（1）子进程收到SIGSTOP；<br>（2）子进程收到SIGCONT；<br>（3）子进程退出   </p>
<p>2 SIGCHLD信号的作用:子进程退出之后, 内核会给其父进程发送SIGCHLD信号, 父进程收到这个信号之后, 调用waitpid或者wait完成对子进程的回收.</p>
<ul>
<li>核心代码（父进程回收子进程）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">//父进程使用SIGCHLD信号完成对子进程的回收</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">void waitchild(int signo)&#123;</span><br><span class="line">	</span><br><span class="line">	pid_t wpid;</span><br><span class="line">	//当有子进程死掉之后，就会执行该回调函数，循环回收子进程，直至无子进程或者只剩下正在执行的子进程时，跳出循环，结束该函数。</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		wpid=waitpid(-1,NULL,WNOHANG);//一次只能回收一个子进程，-1代表可以回收任意子进程</span><br><span class="line">		if(wpid&gt;0)&#123;//回收到子进程</span><br><span class="line">			printf(&quot;child is quit,wpid=[%d]\n&quot;,wpid);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(wpid==0)&#123;//当前有正在运行的子进程，退出回收</span><br><span class="line">			printf(&quot;child is living,wpid=[%d]\n&quot;,wpid);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(wpid==-1)&#123;//无子进程了，退出回收</span><br><span class="line">				printf(&quot;no child,wpid=[%d]\n&quot;,wpid);</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	int i=0;</span><br><span class="line">	//将SIGCHLD信号阻塞</span><br><span class="line">	sigset_t mask;</span><br><span class="line">	sigaddset(&amp;mask,SIGCHLD);</span><br><span class="line">	sigprocmask(SIG_BLOCK,&amp;mask,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">for(;i&lt;3;i++)&#123;</span><br><span class="line">	//创建子进程</span><br><span class="line">//	printf(&quot;before fork, pid=[%d]\n&quot;,getpid());</span><br><span class="line">	pid_t pid=fork();</span><br><span class="line">	if(pid&lt;0)&#123;</span><br><span class="line">		perror(&quot;error&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid&gt;0)&#123; //父进程</span><br><span class="line">		printf(&quot;father: pid=[%d],fpid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid==0)&#123;  //子进程</span><br><span class="line">		printf(&quot;child :pid=[%d],fpid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">		break;		</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">if(i==0)&#123;</span><br><span class="line">	printf(&quot;[%d]--[%d]:child\n&quot;,i,getpid());</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">else if(i==1)&#123;</span><br><span class="line">	printf(&quot;[%d]--[%d]:child\n&quot;,i,getpid());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else if(i==2)&#123;</span><br><span class="line"> printf(&quot;[%d]--[%d]:child\n&quot;,i,getpid());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">else if(i==3)</span><br><span class="line">&#123;</span><br><span class="line">	//注册信号处理函数</span><br><span class="line">	struct sigaction act;</span><br><span class="line">	act.sa_handler=waitchild;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	act.sa_flags=0;</span><br><span class="line">	</span><br><span class="line">	sleep(5);</span><br><span class="line">	sigaction(SIGCHLD,&amp;act,NULL);</span><br><span class="line">	</span><br><span class="line">	//解除对SIGCHLD阻塞</span><br><span class="line">	sigprocmask(SIG_UNBLOCK,&amp;mask,NULL);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//父进程执行其他操作</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码解释：</p>
<ul>
<li><p>问题一：有可能还没有完成对SIGCHLD信号的注册, 三个子进程就全部退出了.<br>解决方法: 在fork之前先将SIGCHLD信号阻塞,阻塞之后不管来多少个SIGCHLD信号，最终在未决集中只存在的是SIGCHLD为1，表示未处理的信号，然后在完成对SIGCHLD信号的注册之后再解除对SIGCHLD信号的阻塞;</p>
</li>
<li><p>问题二：有可能在SIGCHLD信号处理函数执行期间, 另外的2个子进程同时全部退出, 由于信号是不支持排队的，此时来的信号会被阻塞，在信号处理函数结束之后，只会保留一个信号，所以，还会处理回收一个子进程，此时另一个会成为僵尸进程.<br>解决办法: 在信号处理函数中应该循环回收, 当waitpid返回-1的时候就表示已经回收完所有子进程了, 此时可以break;    </p>
</li>
<li><p>内核实现信号捕捉的过程</p>
</li>
</ul>
<p><img src="/images/signal_process.png"></p>
<ul>
<li>正常情况下，不用信号完成进程间的通信！！！</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">进程控制</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-26 20:01:28" itemprop="dateCreated datePublished" datetime="2022-04-26T20:01:28+08:00">2022-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-01 11:54:36" itemprop="dateModified" datetime="2022-05-01T11:54:36+08:00">2022-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="程序和进程的概念"><a href="#程序和进程的概念" class="headerlink" title="程序和进程的概念:"></a>程序和进程的概念:</h1><p>程序: 是编译好的二进制文件, 存放在磁盘上, 占用的是磁盘空间, 是一个静态的概念.<br>进程: 一个启动的程序, 需要占用系统资源: 如 内存, cpu 终端 等<br>剧本—&gt;程序<br>进程—&gt;唱戏(舞台, 灯光, 道具, 人等资源)<br>同一个程序可以在多个终端执行, 类似与同一台戏可以在多个舞台演出.<br>每启动一个程序都会有一个进程PID, 即使是相同的程序多次启动也会有个不同的PID。</p>
<h1 id="并发和并行的概念"><a href="#并发和并行的概念" class="headerlink" title="并发和并行的概念"></a>并发和并行的概念</h1><p>并发: 在一个时间段内, 一个CPU上, 有多个程序在执行.<br>并行: 并行指两个或两个以上的程序在同一时刻发生(需要有多核)。<br>cpu会将一个大的时间段分成多个小的时间片, 让进程轮流使用CPU的时间片.<br>#进程的五态模型和七态模型</p>
<p>#进程创建</p>
<ul>
<li>调用fork函数的内核实现原理:<br><img src="/images/fork.png"><br><img src="/images/fork_two.png"></li>
</ul>
<h2 id="循环创建子进程问题（子进程也会创建子进程）："><a href="#循环创建子进程问题（子进程也会创建子进程）：" class="headerlink" title="循环创建子进程问题（子进程也会创建子进程）："></a>循环创建子进程问题（子进程也会创建子进程）：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> 1 //fork函数测试，循环创建子进程</span><br><span class="line"> 2 #include&lt;stdio.h&gt;</span><br><span class="line"> 3 #include&lt;stdlib.h&gt;</span><br><span class="line"> 4 #include&lt;string.h&gt;</span><br><span class="line"> 5 #include&lt;sys/types.h&gt;</span><br><span class="line"> 6 #include&lt;unistd.h&gt;</span><br><span class="line"> 7</span><br><span class="line"> 8 int main()&#123;</span><br><span class="line"> 9</span><br><span class="line">10     int i=0;</span><br><span class="line">11 for(;i&lt;3;i++)&#123;</span><br><span class="line">12     //创建子进程</span><br><span class="line">13     printf(&quot;before fork, pid=[%d]\n&quot;,getpid());</span><br><span class="line">14     pid_t pid=fork();</span><br><span class="line">15     if(pid&lt;0)&#123;</span><br><span class="line">16         perror(&quot;error&quot;);</span><br><span class="line">17         return -1;</span><br><span class="line">18     &#125;</span><br><span class="line">19     else if(pid&gt;0)&#123; //父进程</span><br><span class="line">20         printf(&quot;father: pid=[%d],fpid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">21     //  sleep(1);</span><br><span class="line">22     &#125;</span><br><span class="line">23     else if(pid==0)&#123;  //子进程</span><br><span class="line">24         printf(&quot;child :pid=[%d],fpid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">25</span><br><span class="line">26         &#125;</span><br><span class="line">27     printf(&quot;after fork, pid=[%d]\n&quot;,getpid());</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31     &#125;</span><br><span class="line">32 return 0;</span><br><span class="line">33 &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主进程总共创建了7个子进程，分析如下：<br><img src="/images/child_fork.png"></p>
<h2 id="修该后的代码"><a href="#修该后的代码" class="headerlink" title="修该后的代码"></a>修该后的代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> 1 //fork函数测试，循环创建子进程</span><br><span class="line"> 2 #include&lt;stdio.h&gt;</span><br><span class="line"> 3 #include&lt;stdlib.h&gt;</span><br><span class="line"> 4 #include&lt;string.h&gt;</span><br><span class="line"> 5 #include&lt;sys/types.h&gt;</span><br><span class="line"> 6 #include&lt;unistd.h&gt;</span><br><span class="line"> 7</span><br><span class="line"> 8 int main()&#123;</span><br><span class="line"> 9</span><br><span class="line">10     int i=0;</span><br><span class="line">11 for(;i&lt;3;i++)&#123;</span><br><span class="line">12     //创建子进程</span><br><span class="line">13     printf(&quot;before fork, pid=[%d]\n&quot;,getpid());</span><br><span class="line">14     pid_t pid=fork();</span><br><span class="line">15     if(pid&lt;0)&#123;</span><br><span class="line">16         perror(&quot;error&quot;);</span><br><span class="line">17         return -1;</span><br><span class="line">18     &#125;</span><br><span class="line">19     else if(pid&gt;0)&#123; //父进程</span><br><span class="line">20         printf(&quot;father: pid=[%d],fpid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">21     //  sleep(1);</span><br><span class="line">22     &#125;</span><br><span class="line">23     else if(pid==0)&#123;  //子进程</span><br><span class="line">24         printf(&quot;child :pid=[%d],fpid=[%d]\n&quot;,getpid(),getppid());</span><br><span class="line">25         break;//只要子进程在此处跳出循环即可！！！</span><br><span class="line">26         &#125;</span><br><span class="line">27     printf(&quot;after fork, pid=[%d]\n&quot;,getpid());</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31     &#125;</span><br><span class="line">32 return 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>只要在子进程代码块中，执行完逻辑后，break出循环就能保证子进程不在创建子进程！！！</p>
<h1 id="父子进程不能共享全局变量（即不能够使用全局变量进行通信！！！）"><a href="#父子进程不能共享全局变量（即不能够使用全局变量进行通信！！！）" class="headerlink" title="父子进程不能共享全局变量（即不能够使用全局变量进行通信！！！）"></a>父子进程不能共享全局变量（即不能够使用全局变量进行通信！！！）</h1><p><img src="/images/global.png"><br>父子进程不能共享全局变量；但是如果父子进程只是对全局变量做读操作，则父子进程在真正的物理内存空间中只有一份，属于共享！但是如果父子进程中的任何一个进程对该变量进行修改操作，会在内存中拷贝一个副本，然后在这个副本上进行修改，修改完成后在映射回虚拟内存空间上去！！！</p>
<ul>
<li><p>总结：写时复制，读时共享！！！</p>
</li>
<li><p>如果想在一个进程内部执行系统命令或者是应用程序, 优先应该想到如下方式:<br>先fork(), 然后在子进程里面执行execl拉起可执行程序或者命令.<br>pid &#x3D; fork();<br>if(pid&#x3D;&#x3D;0)<br>{<br>  execl(…);<br>}</p>
</li>
</ul>
<p>execl: 一般用于执行用户自定义的应用程序.<br>execlp: 一般用于执行系统命令</p>
<ul>
<li><p>exec函数是用一个新程序替换了当前进程的代码段、数据段、堆和栈；原有的进程空间没有发生变化，并没有创建新的进程，进程PID没有发生变化。<br><img src="/images/excel.png"></p>
</li>
<li><p>为什么要对进程资源进行回收？<br>当一个进程退出之后，进程能够回收自己的用户区的资源，但是不能回收内核空间的PCB资源，必须由它的父进程调用wait或者waitpid函数完成对子进程的回收，避免造成系统资源的浪费</p>
</li>
<li><p>孤儿进程<br>父进程先退出，子进程就变成了孤儿进程，此时被init进程领养，当孤儿进程退出后，就会被init进程回收。</p>
</li>
<li><p>僵尸进程<br>子进程先退出，父进程没有完成子进程的回收，此时子进程就变成了僵尸进程。<br>如何解决？<br>不能用kill -9杀死僵尸进程，因为僵尸进程是一个死掉的进程，无法接收信号，<br>应该使用杀死僵尸进程的父进程的方法来解决僵尸进程。<br>原因：杀死其父进程可以让init进程领养僵尸进程，最后init进程回收僵尸进程。</p>
</li>
<li><p>wait函数</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wait函数:</span><br><span class="line">	pid_t wait(int *status);</span><br><span class="line">	返回值:</span><br><span class="line">		&gt;0: 回收的子进程的PID</span><br><span class="line">		-1: 没有子进程</span><br><span class="line">	参数(man 2 wait查看宏定义！):</span><br><span class="line">		status: 子进程的退出状态</span><br><span class="line">			if(WIFEXITED(status))  //正常退出</span><br><span class="line">			&#123;</span><br><span class="line">				WEXITSTATUS(status) //返回退出状态（子进程的返回值）</span><br><span class="line">			&#125;</span><br><span class="line">			else if(WIFSIGNALED(status))//被信号杀死</span><br><span class="line">			&#123;</span><br><span class="line">				WTERMSIG(status) //返回信号的number</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>waitpid函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid,int *status,int options);</span><br><span class="line">参数：</span><br><span class="line">pid</span><br><span class="line">pid&gt;0,表示等待指定的子进程</span><br><span class="line">pid=-1:表示等待任意的子进程</span><br><span class="line">status</span><br><span class="line">同wait函数</span><br><span class="line">options</span><br><span class="line">0：表示阻塞</span><br><span class="line">WNOHANG:表示非阻塞</span><br><span class="line">返回值</span><br><span class="line">&gt;0:表示回收子进程的pid</span><br><span class="line">=0：若是非阻塞的，表示子进程还活着</span><br><span class="line">=-1：表示没有子进程了</span><br><span class="line"></span><br><span class="line">注意：调用一次waitpid或wait函数只能回收一个子进程</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/24/%E6%96%87%E4%BB%B6IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/24/%E6%96%87%E4%BB%B6IO/" class="post-title-link" itemprop="url">文件IO</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-24 10:57:59" itemprop="dateCreated datePublished" datetime="2022-04-24T10:57:59+08:00">2022-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-29 21:38:36" itemprop="dateModified" datetime="2022-04-29T21:38:36+08:00">2022-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C库IO函数的工作流程："><a href="#C库IO函数的工作流程：" class="headerlink" title="C库IO函数的工作流程："></a>C库IO函数的工作流程：</h1><p><img src="/images/file.png"></p>
<p><img src="/images/file1.png"></p>
<ul>
<li>使用fopen函数打开一个文件, 返回一个FILE* fp, 这个指针指向的结构体有三个重要的成员.<br>（1）文件描述符: 通过文件描述可以找到文件的inode, 通过inode可以找到对应的数据块<br>（2）文件指针: 读和写共享一个文件指针, 读或者写都会引起文件指针的变化<br>（3）文件缓冲区: 读或者写会先通过文件缓冲区, 主要目的是为了减少对磁盘的读写次数, 提高读写磁盘的效率.</li>
</ul>
<h1 id="C库函数和系统函数的关系（printf举例）"><a href="#C库函数和系统函数的关系（printf举例）" class="headerlink" title="C库函数和系统函数的关系（printf举例）"></a>C库函数和系统函数的关系（printf举例）</h1><p><img src="/images/printf.png"></p>
<p>库函数和系统函数的关系是: 调用和被调用的关系;库函数是对系统函数的进一步封装.</p>
<p>系统调用: 由操作系统实现并提供给外部应用程序的编程接口(Application Programming Interface, API), 是应用程序同系统之间数据交互的桥梁.</p>
<h1 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h1><p><img src="/images/virtual.png"></p>
<p>以32位系统为例，系统会为每一个进程分配0~4G的空间（虚拟地址空间）。<br>（1）进程的虚拟地址空间分为用户区和内核区, 其中内核区是受保护的, 用户是不能够对其进行读写操作的;<br>（2）内核区中很重要的一个就是进程管理, 进程管理中有一个区域就是PCB(本质是一个结构体);<br>（3）PCB中有文件描述符表, 文件描述符表中存放着打开的文件描述符, 涉及到文件的IO操作都会用到这个文件描述符.</p>
<h1 id="PCB和文件描述符"><a href="#PCB和文件描述符" class="headerlink" title="PCB和文件描述符"></a>PCB和文件描述符</h1><p><img src="/images/pcb.png"></p>
<p>备注:<br>pcb：结构体:task_stuct, 该结构体在:<br>&#x2F;usr&#x2F;src&#x2F;linux-headers-4.4.0-97&#x2F;include&#x2F;linux&#x2F;sched.h:1390<br>一个进程有一个文件描述符表：1024<br>前三个被占用, 分别是STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO<br>文件描述符作用：通过文件描述符找到inode, 通过inode找到磁盘数据块.</p>
<p>虚拟地址空间–&gt;内核区–&gt;进程管理–&gt;pcb–&gt;文件描述表–&gt;文件描述符–&gt;使用IO操作使用文件描述符</p>
<ul>
<li><p>lseek函数常用操作<br>文件指针移动到头部<br>lseek(fd, 0, SEEK_SET);<br>获取文件指针当前位置<br>int len &#x3D; lseek(fd, 0, SEEK_CUR);<br>获取文件长度<br>int len &#x3D; lseek(fd, 0, SEEK_END);<br>lseek实现文件拓展<br>off_t currpos;<br>&#x2F;&#x2F; 从文件尾部开始向后拓展1000个字节<br>currpos &#x3D; lseek(fd, 1000, SEEK_END);<br>&#x2F;&#x2F; 额外执行一次写操作，否则文件无法完成拓展<br>write(fd, “a”, 1);    &#x2F;&#x2F; 数据随便写</p>
</li>
<li><p>文件权限计算方法:<br>mode &amp; ~umask</p>
</li>
<li><p>思考: 阻塞和非阻塞是文件的属性还是read函数的属性?<br>（1）通过读普通文件测试得知: read函数在读完文件内容之后, 若再次read,则read函数会立刻返回, 表明read函数读普通文件是非阻塞的.<br>（2）设备文件:&#x2F;dev&#x2F;tty 和 标准输入STDIN_FILENO，通过读&#x2F;dev&#x2F;tty终端设备文件和标准输入, 表明read函数读设备文件是阻塞的.<br>（3）结论: 阻塞和非阻塞不是read函数的属性, 而是文件本身的属性.<br>socket pipe这两种文件都是阻塞的.</p>
</li>
</ul>
<h1 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h1><ul>
<li>使用st_mode成员判断文件类型:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//方法一</span><br><span class="line">   if((sb.st_mode &amp; S_IFMT) ==S_IFLNK)</span><br><span class="line">   &#123;   </span><br><span class="line">       printf(&quot;连接文件\n&quot;);</span><br><span class="line">   &#125;   </span><br><span class="line">   </span><br><span class="line">//方法二</span><br><span class="line">   if (S_ISREG(sb.st_mode)) </span><br><span class="line">   &#123;   </span><br><span class="line">       printf(&quot;普通文件\n&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>判断文件权限:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> if(sb.st_mode &amp; S_IROTH)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;---R----&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>lstat和stat函数:<br>（1）对于普通文件来说, lstat函数和stat函数一样<br>（2）对于软连接文件来说, lstat函数获取的是连接文件本身的属性,<br>（3）stat函数获取的是连接文件指向的文件的属性.</p>
</li>
<li><p>目录操作:<br>（1）打开目录 opendir<br>（2）循环读目录: readdir<br>（3）关闭目录: closedir</p>
</li>
<li><p>dup和dup2函数:复制文件描述符—-详情看图</p>
</li>
</ul>
<p><img src="/images/dup.png"></p>
<ul>
<li>fcntl函数:<br>(1)复制文件描述符: int fd &#x3D; fcntl(oldfd, F_DUPFD, 0);<br>(2)获得和设置文件的flag属性:<br>int flag &#x3D; fcntl(fd, F_GETFL, 0);<br>flag &#x3D;flag|O_APPEND;<br>fcntl(fd, F_SETFL, flag);</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/23/makefill-gdb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat.png">
      <meta itemprop="name" content="qcc">
      <meta itemprop="description" content="努力变强">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一懒众衫小">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/23/makefill-gdb/" class="post-title-link" itemprop="url">makefill gdb</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-23 18:09:16" itemprop="dateCreated datePublished" datetime="2022-04-23T18:09:16+08:00">2022-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-31 18:54:08" itemprop="dateModified" datetime="2022-07-31T18:54:08+08:00">2022-07-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>makefile:<br>makefile文件是用来管理项目工程文件, 通过执行make命令, make就会解析并执行makefile文件.<br>makefile命名: makefile或者Makefile</p>
</li>
<li><p>makefile的编写:<br>规则如下:<br>目标: 依赖<br>(tab)命令</p>
</li>
<li><p>第一个版本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main: main.c fun1.c fun2.c sum.c</span><br><span class="line">	gcc -o main main.c fun1.c fun2.c sum.c</span><br></pre></td></tr></table></figure>
<p>缺点: 效率低, 修改一个文件, 所有的文件会全部重新编译.</p>
</li>
<li><p>第二个版本：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 main:main.o fun1.o fun2.o</span><br><span class="line">2     gcc -o main main.o fun1.o fun2.o</span><br><span class="line">3 main.o:main.c</span><br><span class="line">4     gcc -c main.c -I ./</span><br><span class="line">5 fun1.o:fun1.c</span><br><span class="line">6     gcc -c fun1.c</span><br><span class="line">7 fun2.o:fun2.c</span><br><span class="line">8     gcc -c fun2.c</span><br></pre></td></tr></table></figure>

<p>检查规则:<br>要想生成目标文件, 先要检查依赖条件是否都存在.<br>若都存在, 则比较目标时间和依赖的时间, 如果依赖的时候比目标的时间新,则重新生成目标; 否则不重新生成.<br>若不存在, 则往下找有没有生成依赖的规则, 有则生成, 如果没有则报错.<br>第二版本的缺点: 冗余, 若.c文件数量很多, 编写起来比较麻烦.</p>
<ul>
<li>第三个版本：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1 target=main</span><br><span class="line"> 2 objects=main.o fun1.o fun2.o</span><br><span class="line"> 3 CC=gcc</span><br><span class="line"> 4 CPPFLAGS=-I./</span><br><span class="line"> 5</span><br><span class="line"> 6 $(target):$(objects)</span><br><span class="line"> 7     $(CC) -o $@ $^</span><br><span class="line"> 8 %.o:%.c</span><br><span class="line"> 9     $(CC) -c $&lt; $(CPPFLAGS)</span><br><span class="line">10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>变量:<br>自定义变量: var &#x3D; hello, $(var)<br>自带变量: CC CPPFLAGS CFLAGS LDFLAGS<br>自动变量: $@ $&lt; $^<br>模式规则: %.o:%.c——&gt; 前后的%必须是相同 </p>
<ul>
<li>第四个版本：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1 target=main</span><br><span class="line"> 2 src=$(wildcard *.c)</span><br><span class="line"> 3 objects=$(patsubst %.c,%.o,$(src))</span><br><span class="line"> 4 CC=gcc</span><br><span class="line"> 5 CPPFLAGS=-I./</span><br><span class="line"> 6</span><br><span class="line"> 7 $(target):$(objects)</span><br><span class="line"> 8     $(CC) -o $@ $^</span><br><span class="line"> 9 %.o:%.c</span><br><span class="line">10     $(CC) -c $&lt; $(CPPFLAGS)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>makefile函数：<br>1.wildcard – 查找指定目录下的指定类型的文件<br>src&#x3D;$(wildcard *.c)  &#x2F;&#x2F;找到当前目录下所有后缀为.c的文件,赋值给src<br>2.patsubst – 匹配替换<br>obj&#x3D;$(patsubst %.c,%.o, $(src)) &#x2F;&#x2F;把src变量里所有后缀为.c的文件替换成.o<br>如: 当前目录下有a.c b.c c.c<br>src&#x3D;$(wildcard *.c) —–&gt; src&#x3D;a.c b.c c.c<br>obj&#x3D;$(patsubst %.c,%.o, $(src)) —–&gt; obj&#x3D;a.o b.o c.o</p>
<ul>
<li>第五个版本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 1 target=main</span><br><span class="line"> 2 src=$(wildcard *.c)</span><br><span class="line"> 3 objects=$(patsubst %.c,%.o,$(src))</span><br><span class="line"> 4 CC=gcc</span><br><span class="line"> 5 CPPFLAGS=-I./</span><br><span class="line"> 6</span><br><span class="line"> 7 $(target):$(objects)  #第一个目标即为终极目标，直接make就会运行！！！</span><br><span class="line"> 8     $(CC) -o $@ $^</span><br><span class="line"> 9 %.o:%.c</span><br><span class="line">10     $(CC) -c $&lt; $(CPPFLAGS)</span><br><span class="line">11</span><br><span class="line">12 .PHONY:clean  #声明为伪目标。   非第一个目标，make clean才会运行嗷</span><br><span class="line">13 clean:</span><br><span class="line">14     -rm -f $(objects) $(target)   #rm前加-,可以保证clean下的前一个命令如果无法执行，不会影响在其后面加-的命令的执行！   rm -f: 强制执行, 比如若要删除的文件不存在使用-f不会报错。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>增加清理功能.<br>终极目标: makefile文件中第一次出现的目标叫做终极目标。<br>伪目标：声明目标为伪目标之后, makefile将不会检查该目标是否存在或者该目标是否需要更新。<br>.PHONY:clean<br>clean:<br>rm -f ….        </p>
<ul>
<li><p>使用-f可以指定makefile文件（因为执行make默认找的是makefile文件，通过-f参数可以指定其他名称的makefile文件）, 如: make -f new_makefile</p>
</li>
<li><p>gdb调试 :</p>
</li>
</ul>
<p>gdb是在程序运行的结果与预期不符合的时候, 可以使用gdb进行调试,<br>特别注意的是: 使用gdb调试需要在编译的时候加-g参数!!!!!!!</p>
<p>启动gdb:<br>gdb program<br>set args hello world<br>show args<br>执行程序:<br>run  #执行到断点位置，无断点，则执行完<br>start #第一条语句停下来</p>
<p>list操作:<br>list<br>list -<br>list func<br>list linenum<br>list file:func<br>list file:linenum<br>set listsize n<br>show listsize</p>
<p>断点操作:<br>b linenum<br>b func<br>b file:linenum<br>b file:func</p>
<p>info break</p>
<p>disable m n | m-n<br>enable  m n | m-n<br>delete m n | m-n </p>
<p>条件断点<br>一般来说, 为断点设置一个条件, 我们使用if关键词, 后面跟其断点条件。设置一个条件断点：<br>b test.c:8 if intValue &#x3D;&#x3D; 5</p>
<p>调试命令:<br>run （全部执行，直至第一个断点处）<br>start （执行至第一条语句）<br>next  （单步执行，不进入函数体）<br>step  （单步执行，进入函数体）<br>finish  （跳出函数体）<br>until  （执行完循环体）<br>continue  （执行至下一个断点处）</p>
<p>print var  （打印变量值）</p>
<p>自动显示:<br>display var  （显示变量）</p>
<p>info display  （列出所有需要显示的变量信息）</p>
<p>disable display m n | m-n   （使变量显示失效）<br>enable display m n | m-n     （使变量显示生效）</p>
<p>delete display m n | m-n   （删除需要显示的变量）<br>undisplay m n | m-n    （删除需要显示的变量）</p>
<p>多进程调试？？？？</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="qcc"
      src="/images/cat.png">
  <p class="site-author-name" itemprop="name">qcc</p>
  <div class="site-description" itemprop="description">努力变强</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/iwsuccess" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;iwsuccess" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2274259107@qq.com" title="E-Mail → mailto:2274259107@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      链接网站
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://leetcode-cn.com/u/mou-gai/" title="https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;mou-gai&#x2F;" rel="noopener" target="_blank">leetcode</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-03 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qcc</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共39.8k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
